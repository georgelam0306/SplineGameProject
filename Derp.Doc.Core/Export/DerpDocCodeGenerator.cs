using System.Globalization;
using System.Text;
using Derp.Doc.Model;

namespace Derp.Doc.Export;

internal static class DerpDocCodeGenerator
{
    public static List<GeneratedFile> Generate(
        List<ExportTableModel> exportTables,
        string binaryFileName)
    {
        if (exportTables.Count == 0)
        {
            return new List<GeneratedFile>();
        }

        string ns = exportTables[0].Namespace;

        var files = new List<GeneratedFile>();

        files.Add(new GeneratedFile("DerpDocKeyRowIndexPair.g.cs", RenderKeyRowIndexPair(ns)));
        files.Add(new GeneratedFile("DerpDocRangeStartCountPair.g.cs", RenderRangeStartCountPair(ns)));
        files.Add(new GeneratedFile("DerpDocTagPkPair.g.cs", RenderTagPkPair(ns)));

        var enumsByName = CollectEnums(exportTables);
        foreach (var kvp in enumsByName)
        {
            files.Add(new GeneratedFile(kvp.Key + ".g.cs", RenderEnum(ns, kvp.Value)));
        }

        for (int i = 0; i < exportTables.Count; i++)
        {
            var t = exportTables[i];
            files.Add(new GeneratedFile(t.StructName + ".g.cs", RenderRecordStruct(ns, t)));
            files.Add(new GeneratedFile(t.StructName + "Table.g.cs", RenderTableWrapper(ns, t)));
            files.Add(new GeneratedFile(t.StructName + "Runtime.g.cs", RenderTableRuntime(ns, t, exportTables, i)));
        }

        files.Add(new GeneratedFile("GameDatabase.g.cs", RenderGameDatabase(ns, exportTables, binaryFileName)));

        return files;
    }

    private static Dictionary<string, ExportEnumModel> CollectEnums(List<ExportTableModel> exportTables)
    {
        var enums = new Dictionary<string, ExportEnumModel>(StringComparer.Ordinal);

        for (int i = 0; i < exportTables.Count; i++)
        {
            var t = exportTables[i];
            for (int c = 0; c < t.Columns.Count; c++)
            {
                var col = t.Columns[c];
                if (col.EnumModel == null)
                {
                    continue;
                }

                // If names collide, prefer the first; exporter validates collisions separately.
                enums.TryAdd(col.EnumModel.EnumName, col.EnumModel);
            }

            if (t.PrimaryKey?.EnumModel != null)
            {
                enums.TryAdd(t.PrimaryKey.EnumModel.EnumName, t.PrimaryKey.EnumModel);
            }

            for (int s = 0; s < t.SecondaryKeys.Count; s++)
            {
                if (t.SecondaryKeys[s].EnumModel != null)
                {
                    enums.TryAdd(t.SecondaryKeys[s].EnumModel!.EnumName, t.SecondaryKeys[s].EnumModel!);
                }
            }
        }

        return enums;
    }

    private static string RenderPreamble(string ns)
    {
        var sb = new StringBuilder(256);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        return sb.ToString();
    }

    private static string RenderKeyRowIndexPair(string ns)
    {
        var sb = new StringBuilder(512);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.AppendLine("internal readonly struct DerpDocKeyRowIndexPair");
        sb.AppendLine("{");
        sb.AppendLine("    public readonly int Key;");
        sb.AppendLine("    public readonly int RowIndex;");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderRangeStartCountPair(string ns)
    {
        var sb = new StringBuilder(512);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.AppendLine("internal readonly struct DerpDocRangeStartCountPair");
        sb.AppendLine("{");
        sb.AppendLine("    public readonly int Start;");
        sb.AppendLine("    public readonly int Count;");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderTagPkPair(string ns)
    {
        var sb = new StringBuilder(512);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.AppendLine("internal readonly struct DerpDocTagPkPair");
        sb.AppendLine("{");
        sb.AppendLine("    public readonly int Tag;");
        sb.AppendLine("    public readonly int Pk;");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderEnum(string ns, ExportEnumModel model)
    {
        var sb = new StringBuilder(1024);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.Append("public enum ").Append(model.EnumName).Append(" : ").Append(model.UnderlyingTypeName).AppendLine();
        sb.AppendLine("{");

        if (!model.IsKey)
        {
            sb.AppendLine("    None = 0,");
        }

        for (int i = 0; i < model.Options.Count; i++)
        {
            string member = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(model.Options[i]), "Option");
            int value = i + model.ValueOffset;
            sb.Append("    ").Append(member).Append(" = ").Append(value).AppendLine(",");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderRecordStruct(string ns, ExportTableModel table)
    {
        var sb = new StringBuilder(4096);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using Core;");
        sb.AppendLine("using FixedMath;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.Append("public struct ").Append(table.StructName).AppendLine();
        sb.AppendLine("{");

        for (int i = 0; i < table.Columns.Count; i++)
        {
            var col = table.Columns[i];
            sb.Append("    public ").Append(col.FieldTypeName).Append(' ').Append(col.FieldName).AppendLine(";");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderTableWrapper(string ns, ExportTableModel table)
    {
        var sb = new StringBuilder(12288);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using DerpDoc.Runtime;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();

        bool hasPk = table.PrimaryKey != null;
        ExportSubtableLinkModel? subtableParent = table.SubtableParent;
        ExportTableModel? subtableParentTable = subtableParent?.ParentTable;
        ExportRowReferenceModel? primaryRowReference = table.RowReferences.Count > 0 ? table.RowReferences[0] : null;
        bool hasPrimaryRowReference = primaryRowReference != null;
        string? subtableParentFieldName = null;
        if (subtableParent != null)
        {
            for (int columnIndex = 0; columnIndex < table.Columns.Count; columnIndex++)
            {
                if (string.Equals(table.Columns[columnIndex].SourceColumn.Id, subtableParent.ChildParentRowColumn.Id, StringComparison.Ordinal))
                {
                    subtableParentFieldName = table.Columns[columnIndex].FieldName;
                    break;
                }
            }

            subtableParentFieldName ??= CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(subtableParent.ChildParentRowColumn.Name), "ParentId");
        }

        sb.Append("public struct ").Append(table.StructName).AppendLine("Table");
        sb.AppendLine("{");
        sb.Append("    private readonly TableAccessor<").Append(table.StructName).AppendLine("> _table;");

        if (hasPk)
        {
            sb.AppendLine("    private readonly TableAccessor<DerpDocKeyRowIndexPair> _pkSorted;");
        }

        for (int i = 0; i < table.SecondaryKeys.Count; i++)
        {
            var sk = table.SecondaryKeys[i];
            string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(sk.Column.Name), "Key");
            if (sk.Unique)
            {
                sb.Append("    private readonly TableAccessor<int> _mapBy").Append(keyName).AppendLine(";");
            }
            else
            {
                sb.Append("    private readonly TableAccessor<DerpDocKeyRowIndexPair> _pairsBy").Append(keyName).AppendLine(";");
            }
        }

        if (subtableParent != null)
        {
            sb.AppendLine("    private readonly TableAccessor<DerpDocRangeStartCountPair> _subParentRanges;");
            sb.AppendLine("    private readonly TableAccessor<int> _subParentRows;");
        }

        if (hasPrimaryRowReference && primaryRowReference != null)
        {
            string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
            sb.Append("    private readonly TableAccessor<DerpDocTagPkPair> _rowRef").Append(rowRefStem).AppendLine("RowTargets;");
            sb.Append("    private readonly TableAccessor<DerpDocRangeStartCountPair> _rowRef").Append(rowRefStem).AppendLine("ParentKindRanges;");
            sb.Append("    private readonly TableAccessor<int> _rowRef").Append(rowRefStem).AppendLine("ParentKindRows;");
            sb.Append("    private readonly TableAccessor<DerpDocRangeStartCountPair> _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetMeta;");
            sb.Append("    private readonly TableAccessor<DerpDocRangeStartCountPair> _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRanges;");
            sb.Append("    private readonly TableAccessor<int> _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRows;");
            sb.Append("    private readonly TableAccessor<DerpDocRangeStartCountPair> _rowRef").Append(rowRefStem).AppendLine("ParentTargetMeta;");
            sb.Append("    private readonly TableAccessor<DerpDocRangeStartCountPair> _rowRef").Append(rowRefStem).AppendLine("ParentTargetRanges;");
            sb.Append("    private readonly TableAccessor<int> _rowRef").Append(rowRefStem).AppendLine("ParentTargetRows;");
        }

        for (int linkIndex = 0; linkIndex < table.SubtableChildren.Count; linkIndex++)
        {
            ExportSubtableLinkModel link = table.SubtableChildren[linkIndex];
            sb.Append("    private ").Append(link.ChildTable.StructName).Append("Table _subtable").Append(link.PropertyName).AppendLine(";");
        }

        sb.AppendLine();
        sb.Append("    internal ").Append(table.StructName).Append("Table(");
        sb.Append("TableAccessor<").Append(table.StructName).Append("> table");
        if (hasPk)
        {
            sb.Append(", TableAccessor<DerpDocKeyRowIndexPair> pkSorted");
        }
        for (int i = 0; i < table.SecondaryKeys.Count; i++)
        {
            var sk = table.SecondaryKeys[i];
            string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(sk.Column.Name), "Key");
            if (sk.Unique)
            {
                sb.Append(", TableAccessor<int> mapBy").Append(keyName);
            }
            else
            {
                sb.Append(", TableAccessor<DerpDocKeyRowIndexPair> pairsBy").Append(keyName);
            }
        }
        if (subtableParent != null)
        {
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> subParentRanges");
            sb.Append(", TableAccessor<int> subParentRows");
        }
        if (hasPrimaryRowReference && primaryRowReference != null)
        {
            string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
            sb.Append(", TableAccessor<DerpDocTagPkPair> rowRef").Append(rowRefStem).Append("RowTargets");
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> rowRef").Append(rowRefStem).Append("ParentKindRanges");
            sb.Append(", TableAccessor<int> rowRef").Append(rowRefStem).Append("ParentKindRows");
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> rowRef").Append(rowRefStem).Append("ParentKindTargetMeta");
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> rowRef").Append(rowRefStem).Append("ParentKindTargetRanges");
            sb.Append(", TableAccessor<int> rowRef").Append(rowRefStem).Append("ParentKindTargetRows");
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> rowRef").Append(rowRefStem).Append("ParentTargetMeta");
            sb.Append(", TableAccessor<DerpDocRangeStartCountPair> rowRef").Append(rowRefStem).Append("ParentTargetRanges");
            sb.Append(", TableAccessor<int> rowRef").Append(rowRefStem).Append("ParentTargetRows");
        }
        sb.AppendLine(")");
        sb.AppendLine("    {");
        sb.AppendLine("        _table = table;");
        if (hasPk)
        {
            sb.AppendLine("        _pkSorted = pkSorted;");
        }
        for (int i = 0; i < table.SecondaryKeys.Count; i++)
        {
            var sk = table.SecondaryKeys[i];
            string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(sk.Column.Name), "Key");
            if (sk.Unique)
            {
                sb.Append("        _mapBy").Append(keyName).Append(" = mapBy").Append(keyName).AppendLine(";");
            }
            else
            {
                sb.Append("        _pairsBy").Append(keyName).Append(" = pairsBy").Append(keyName).AppendLine(";");
            }
        }
        if (subtableParent != null)
        {
            sb.AppendLine("        _subParentRanges = subParentRanges;");
            sb.AppendLine("        _subParentRows = subParentRows;");
        }
        if (hasPrimaryRowReference && primaryRowReference != null)
        {
            string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
            sb.Append("        _rowRef").Append(rowRefStem).Append("RowTargets = rowRef").Append(rowRefStem).AppendLine("RowTargets;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentKindRanges = rowRef").Append(rowRefStem).AppendLine("ParentKindRanges;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentKindRows = rowRef").Append(rowRefStem).AppendLine("ParentKindRows;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentKindTargetMeta = rowRef").Append(rowRefStem).AppendLine("ParentKindTargetMeta;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentKindTargetRanges = rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRanges;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentKindTargetRows = rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRows;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentTargetMeta = rowRef").Append(rowRefStem).AppendLine("ParentTargetMeta;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentTargetRanges = rowRef").Append(rowRefStem).AppendLine("ParentTargetRanges;");
            sb.Append("        _rowRef").Append(rowRefStem).Append("ParentTargetRows = rowRef").Append(rowRefStem).AppendLine("ParentTargetRows;");
        }
        for (int linkIndex = 0; linkIndex < table.SubtableChildren.Count; linkIndex++)
        {
            ExportSubtableLinkModel link = table.SubtableChildren[linkIndex];
            sb.Append("        _subtable").Append(link.PropertyName).AppendLine(" = default;");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        if (table.SubtableChildren.Count > 0)
        {
            sb.Append("    internal void ConnectSubtables(");
            for (int linkIndex = 0; linkIndex < table.SubtableChildren.Count; linkIndex++)
            {
                ExportSubtableLinkModel link = table.SubtableChildren[linkIndex];
                if (linkIndex > 0)
                {
                    sb.Append(", ");
                }

                sb.Append(link.ChildTable.StructName).Append("Table subtable").Append(link.PropertyName);
            }
            sb.AppendLine(")");
            sb.AppendLine("    {");
            for (int linkIndex = 0; linkIndex < table.SubtableChildren.Count; linkIndex++)
            {
                ExportSubtableLinkModel link = table.SubtableChildren[linkIndex];
                sb.Append("        _subtable").Append(link.PropertyName).Append(" = subtable").Append(link.PropertyName).AppendLine(";");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    public int Count => _table.Count;");
        sb.Append("    public ReadOnlySpan<").Append(table.StructName).AppendLine("> All => _table.All;");
        sb.AppendLine();

        if (hasPk)
        {
            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("    public bool TryFindById(int id, out ").Append(table.StructName).AppendLine(" result)");
            sb.AppendLine("    {");
            sb.AppendLine("        return _table.TryFindById(id, out result);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("    public ref readonly ").Append(table.StructName).AppendLine(" FindById(int id)");
            sb.AppendLine("    {");
            sb.AppendLine("        return ref _table.FindById(id);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.Append("    public MatchRange FindRangeById(int min, int max)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        var pairs = _pkSorted.All;");
            sb.AppendLine("        int start = LowerBound(pairs, min);");
            sb.AppendLine("        int end = UpperBound(pairs, max);");
            sb.AppendLine("        int count = end - start;");
            sb.AppendLine("        return count <= 0 ? default : new MatchRange(_table, _pkSorted, start, count);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        for (int i = 0; i < table.SecondaryKeys.Count; i++)
        {
            var sk = table.SecondaryKeys[i];
            string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(sk.Column.Name), "Key");
            sb.Append("    public ").Append(sk.Unique ? "bool" : "MatchRange").Append(" ").Append(sk.Unique ? "TryFindBy" : "FindBy").Append(keyName);
            sb.Append(sk.Unique ? $"(int key, out {table.StructName} result)" : "(int key)");
            sb.AppendLine();
            sb.AppendLine("    {");

            if (sk.Unique)
            {
                sb.AppendLine("        result = default;");
                sb.Append("        var map = _mapBy").Append(keyName).AppendLine(".All;");
                sb.AppendLine("        if ((uint)key >= (uint)map.Length) return false;");
                sb.AppendLine("        int rowIndex = map[key];");
                sb.AppendLine("        if (rowIndex < 0) return false;");
                sb.AppendLine("        result = _table.GetAtIndex(rowIndex);");
                sb.AppendLine("        return true;");
            }
            else
            {
                sb.Append("        var pairs = _pairsBy").Append(keyName).AppendLine(".All;");
                sb.AppendLine("        int start = LowerBound(pairs, key);");
                sb.AppendLine("        int end = UpperBoundExact(pairs, key);");
                sb.AppendLine("        int count = end - start;");
                sb.AppendLine("        return count <= 0 ? default : new MatchRange(_table, _pairsBy" + keyName + ", start, count);");
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }

        if (subtableParent != null && subtableParentTable != null && hasPk && !string.IsNullOrWhiteSpace(subtableParentFieldName))
        {
            sb.Append("    internal ParentScopedRange FindByParentId(int parentId)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        var ranges = _subParentRanges.All;");
            sb.AppendLine("        if ((uint)parentId >= (uint)ranges.Length)");
            sb.AppendLine("        {");
            sb.AppendLine("            return default;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        DerpDocRangeStartCountPair range = ranges[parentId];");
            sb.AppendLine("        return range.Count <= 0 ? default : new ParentScopedRange(_table, _subParentRows, range.Start, range.Count);");
            sb.AppendLine("    }");
            sb.AppendLine();

            if (hasPrimaryRowReference && primaryRowReference != null)
            {
                string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
                sb.Append("    private const int RowRef").Append(rowRefStem).Append("KindCount = ")
                    .Append(primaryRowReference.Targets.Count.ToString(CultureInfo.InvariantCulture)).AppendLine(";");
                sb.AppendLine();

                sb.Append("    [MethodImpl(MethodImplOptions.AggressiveInlining)]").AppendLine();
                sb.Append("    private bool TryResolveRowRef").Append(rowRefStem).Append("Placement(int placementId, out ").Append(table.StructName).AppendLine(" row, out int tag, out int targetPk)");
                sb.AppendLine("    {");
                sb.AppendLine("        tag = -1;");
                sb.AppendLine("        targetPk = -1;");
                sb.AppendLine("        if (!_table.TryFindById(placementId, out row))");
                sb.AppendLine("        {");
                sb.AppendLine("            return false;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        var slots = _table.SlotArray;");
                sb.AppendLine("        if ((uint)placementId >= (uint)slots.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return false;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        int rowIndex = slots[placementId];");
                sb.Append("        if ((uint)rowIndex >= (uint)_rowRef").Append(rowRefStem).AppendLine("RowTargets.Count)");
                sb.AppendLine("        {");
                sb.AppendLine("            return false;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        DerpDocTagPkPair pair = _rowRef").Append(rowRefStem).AppendLine("RowTargets.GetAtIndex(rowIndex);");
                sb.AppendLine("        tag = pair.Tag;");
                sb.AppendLine("        targetPk = pair.Pk;");
                sb.AppendLine("        return tag > 0 && targetPk >= 0;");
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.Append("    internal ParentScopedRange FindRowRef").Append(rowRefStem).Append("ByParentAndKind(int parentId, int tagIndex)").AppendLine();
                sb.AppendLine("    {");
                sb.AppendLine("        if (parentId < 0)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        if ((uint)tagIndex >= (uint)RowRef").Append(rowRefStem).AppendLine("KindCount)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        int slot = checked(parentId * RowRef").Append(rowRefStem).AppendLine("KindCount + tagIndex);");
                sb.Append("        var ranges = _rowRef").Append(rowRefStem).AppendLine("ParentKindRanges.All;");
                sb.AppendLine("        if ((uint)slot >= (uint)ranges.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        DerpDocRangeStartCountPair range = ranges[slot];");
                sb.Append("        return range.Count <= 0 ? default : new ParentScopedRange(_table, _rowRef").Append(rowRefStem).AppendLine("ParentKindRows, range.Start, range.Count);");
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.Append("    internal ParentScopedRange FindRowRef").Append(rowRefStem).Append("ByParentAndKindTargetId(int parentId, int tagIndex, int targetPk)").AppendLine();
                sb.AppendLine("    {");
                sb.AppendLine("        if (parentId < 0 || targetPk < 0)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        if ((uint)tagIndex >= (uint)RowRef").Append(rowRefStem).AppendLine("KindCount)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        int slot = checked(parentId * RowRef").Append(rowRefStem).AppendLine("KindCount + tagIndex);");
                sb.Append("        var meta = _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetMeta.All;");
                sb.AppendLine("        if ((uint)slot >= (uint)meta.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        DerpDocRangeStartCountPair slotMeta = meta[slot];");
                sb.AppendLine("        if ((uint)targetPk >= (uint)slotMeta.Count)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        int rangeIndex = slotMeta.Start + targetPk;").AppendLine();
                sb.Append("        var ranges = _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRanges.All;");
                sb.AppendLine("        if ((uint)rangeIndex >= (uint)ranges.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        DerpDocRangeStartCountPair range = ranges[rangeIndex];");
                sb.Append("        return range.Count <= 0 ? default : new ParentScopedRange(_table, _rowRef").Append(rowRefStem).AppendLine("ParentKindTargetRows, range.Start, range.Count);");
                sb.AppendLine("    }");
                sb.AppendLine();

                sb.Append("    internal ParentScopedRange FindRowRef").Append(rowRefStem).Append("ByParentAndTargetId(int parentId, int targetPk)").AppendLine();
                sb.AppendLine("    {");
                sb.AppendLine("        if (parentId < 0 || targetPk < 0)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        var meta = _rowRef").Append(rowRefStem).AppendLine("ParentTargetMeta.All;");
                sb.AppendLine("        if ((uint)parentId >= (uint)meta.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        DerpDocRangeStartCountPair slotMeta = meta[parentId];");
                sb.AppendLine("        if ((uint)targetPk >= (uint)slotMeta.Count)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        int rangeIndex = slotMeta.Start + targetPk;");
                sb.Append("        var ranges = _rowRef").Append(rowRefStem).AppendLine("ParentTargetRanges.All;");
                sb.AppendLine("        if ((uint)rangeIndex >= (uint)ranges.Length)");
                sb.AppendLine("        {");
                sb.AppendLine("            return default;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        DerpDocRangeStartCountPair range = ranges[rangeIndex];");
                sb.Append("        return range.Count <= 0 ? default : new ParentScopedRange(_table, _rowRef").Append(rowRefStem).AppendLine("ParentTargetRows, range.Start, range.Count);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }

            sb.Append("    public ParentScope ScopeByParent(int parentId, ").Append(subtableParentTable.StructName).AppendLine("Table parentTable)");
            sb.AppendLine("    {");
            sb.AppendLine("        return new ParentScope(this, parentTable, parentId);");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    public readonly struct ParentScope");
            sb.AppendLine("    {");
            sb.Append("        private readonly ").Append(table.StructName).AppendLine("Table _table;");
            sb.Append("        private readonly ").Append(subtableParentTable.StructName).AppendLine("Table _parentTable;");
            sb.AppendLine("        private readonly int _parentId;");
            sb.AppendLine();
            sb.Append("        internal ParentScope(").Append(table.StructName).Append("Table table, ").Append(subtableParentTable.StructName).AppendLine("Table parentTable, int parentId)");
            sb.AppendLine("        {");
            sb.AppendLine("            _table = table;");
            sb.AppendLine("            _parentTable = parentTable;");
            sb.AppendLine("            _parentId = parentId;");
            sb.AppendLine("        }");
            sb.AppendLine();
            if (hasPrimaryRowReference && primaryRowReference != null)
            {
                string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
                sb.AppendLine("        public ParentScopedRange AllRows => _table.FindByParentId(_parentId);");
                sb.AppendLine("        public ParentScopedRange All => AllRows;");
                sb.AppendLine();
                sb.Append("        public bool TryFindPlacementById(int id, out ").Append(table.StructName).AppendLine("ScopedRow result)");
                sb.AppendLine("        {");
                sb.AppendLine("            result = default;");
                sb.Append("            if (!_table.TryFindById(id, out ").Append(table.StructName).AppendLine(" row))");
                sb.AppendLine("            {");
                sb.AppendLine("                return false;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.Append("            if (row.").Append(subtableParentFieldName).AppendLine(" != _parentId)");
                sb.AppendLine("            {");
                sb.AppendLine("                return false;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.Append("            result = new ").Append(table.StructName).AppendLine("ScopedRow(_table, _parentTable, id, _parentId);");
                sb.AppendLine("            return true;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        public ").Append(table.StructName).AppendLine("ScopedRow FindPlacementById(int id)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (!TryFindPlacementById(id, out var result))");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new KeyNotFoundException(\"Placement row not found in scoped subtable range.\");");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            return result;");
                sb.AppendLine("        }");
                sb.AppendLine();

                sb.AppendLine("        public bool TryFindById(int id, out ParentScopedRange result)");
                sb.AppendLine("        {");
                sb.Append("            result = _table.FindRowRef").Append(rowRefStem).AppendLine("ByParentAndTargetId(_parentId, id);");
                sb.AppendLine("            return result.Count > 0;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        public ParentScopedRange FindById(int id)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (!TryFindById(id, out ParentScopedRange result))");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new KeyNotFoundException(\"No matching row-reference placements were found for id.\");");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            return result;");
                sb.AppendLine("        }");
                sb.AppendLine();

                for (int targetIndex = 0; targetIndex < primaryRowReference.Targets.Count; targetIndex++)
                {
                    ExportRowReferenceTargetModel target = primaryRowReference.Targets[targetIndex];
                    string typedScopeName = table.StructName + rowRefStem + target.PropertyName + "Scope";
                    sb.Append("        public ").Append(typedScopeName).Append(' ').Append(target.PropertyName).AppendLine();
                    sb.AppendLine("        {");
                    sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.Append("            get => new ").Append(typedScopeName).Append("(_table, _parentTable, _parentId);").AppendLine();
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
            }
            else
            {
                sb.AppendLine("        public ParentScopedRange All => _table.FindByParentId(_parentId);");
                sb.AppendLine();
                sb.Append("        public bool TryFindById(int id, out ").Append(table.StructName).AppendLine("ScopedRow result)");
                sb.AppendLine("        {");
                sb.AppendLine("            result = default;");
                sb.Append("            if (!_table.TryFindById(id, out ").Append(table.StructName).AppendLine(" row))");
                sb.AppendLine("            {");
                sb.AppendLine("                return false;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.Append("            if (row.").Append(subtableParentFieldName).AppendLine(" != _parentId)");
                sb.AppendLine("            {");
                sb.AppendLine("                return false;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.Append("            result = new ").Append(table.StructName).AppendLine("ScopedRow(_table, _parentTable, id, _parentId);");
                sb.AppendLine("            return true;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.Append("        public ").Append(table.StructName).AppendLine("ScopedRow FindById(int id)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (!TryFindById(id, out var result))");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new KeyNotFoundException(\"Row not found in scoped subtable range.\");");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            return result;");
                sb.AppendLine("        }");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            if (hasPrimaryRowReference && primaryRowReference != null)
            {
                string rowRefStem = CSharpIdentifier.Sanitize(primaryRowReference.PropertyName, "RowRef");
                for (int targetIndex = 0; targetIndex < primaryRowReference.Targets.Count; targetIndex++)
                {
                    ExportRowReferenceTargetModel target = primaryRowReference.Targets[targetIndex];
                    string typedScopeName = table.StructName + rowRefStem + target.PropertyName + "Scope";
                    int tagIndex = target.TagIndex;
                    int tag = target.Tag;

                    sb.Append("    public readonly struct ").Append(typedScopeName).AppendLine();
                    sb.AppendLine("    {");
                    sb.Append("        private readonly ").Append(table.StructName).AppendLine("Table _table;");
                    sb.Append("        private readonly ").Append(subtableParentTable.StructName).AppendLine("Table _parentTable;");
                    sb.AppendLine("        private readonly int _parentId;");
                    sb.AppendLine();
                    sb.Append("        internal ").Append(typedScopeName).Append('(').Append(table.StructName).Append("Table table, ")
                        .Append(subtableParentTable.StructName).AppendLine("Table parentTable, int parentId)");
                    sb.AppendLine("        {");
                    sb.AppendLine("            _table = table;");
                    sb.AppendLine("            _parentTable = parentTable;");
                    sb.AppendLine("            _parentId = parentId;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("        public int Count => All.Count;");
                    sb.Append("        public ParentScopedRange All => _table.FindRowRef").Append(rowRefStem).Append("ByParentAndKind(_parentId, ")
                        .Append(tagIndex.ToString(CultureInfo.InvariantCulture)).AppendLine(");");
                    sb.AppendLine();
                    sb.Append("        public bool TryFindPlacementById(int id, out ").Append(table.StructName).AppendLine("ScopedRow result)");
                    sb.AppendLine("        {");
                    sb.AppendLine("            result = default;");
                    sb.Append("            if (!_table.TryResolveRowRef").Append(rowRefStem).Append("Placement(id, out ").Append(table.StructName).Append(" row, out int tag, out int _))").AppendLine();
                    sb.AppendLine("            {");
                    sb.AppendLine("                return false;");
                    sb.AppendLine("            }");
                    sb.AppendLine();
                    sb.Append("            if (row.").Append(subtableParentFieldName).Append(" != _parentId || tag != ").Append(tag.ToString(CultureInfo.InvariantCulture)).AppendLine(")");
                    sb.AppendLine("            {");
                    sb.AppendLine("                return false;");
                    sb.AppendLine("            }");
                    sb.AppendLine();
                    sb.Append("            result = new ").Append(table.StructName).AppendLine("ScopedRow(_table, _parentTable, id, _parentId);");
                    sb.AppendLine("            return true;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.Append("        public ").Append(table.StructName).AppendLine("ScopedRow FindPlacementById(int id)");
                    sb.AppendLine("        {");
                    sb.AppendLine("            if (!TryFindPlacementById(id, out var result))");
                    sb.AppendLine("            {");
                    sb.AppendLine("                throw new KeyNotFoundException(\"Placement row not found for typed row-reference scope.\");");
                    sb.AppendLine("            }");
                    sb.AppendLine();
                    sb.AppendLine("            return result;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("        public bool TryFindById(int id, out ParentScopedRange result)");
                    sb.AppendLine("        {");
                    sb.Append("            result = _table.FindRowRef").Append(rowRefStem).Append("ByParentAndKindTargetId(_parentId, ")
                        .Append(tagIndex.ToString(CultureInfo.InvariantCulture)).AppendLine(", id);");
                    sb.AppendLine("            return result.Count > 0;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("        public ParentScopedRange FindById(int id)");
                    sb.AppendLine("        {");
                    sb.AppendLine("            if (!TryFindById(id, out ParentScopedRange result))");
                    sb.AppendLine("            {");
                    sb.AppendLine("                throw new KeyNotFoundException(\"No matching row-reference placements were found for id in typed scope.\");");
                    sb.AppendLine("            }");
                    sb.AppendLine();
                    sb.AppendLine("            return result;");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                    sb.AppendLine("    }");
                    sb.AppendLine();
                }
            }

            sb.Append("    public readonly struct ").Append(table.StructName).AppendLine("ScopedRow");
            sb.AppendLine("    {");
            sb.Append("        private readonly ").Append(table.StructName).AppendLine("Table _table;");
            sb.Append("        private readonly ").Append(subtableParentTable.StructName).AppendLine("Table _parentTable;");
            sb.AppendLine("        private readonly int _rowId;");
            sb.AppendLine("        private readonly int _parentId;");
            sb.AppendLine();
            sb.Append("        internal ").Append(table.StructName).Append("ScopedRow(").Append(table.StructName).Append("Table table, ").Append(subtableParentTable.StructName).AppendLine("Table parentTable, int rowId, int parentId)");
            sb.AppendLine("        {");
            sb.AppendLine("            _table = table;");
            sb.AppendLine("            _parentTable = parentTable;");
            sb.AppendLine("            _rowId = rowId;");
            sb.AppendLine("            _parentId = parentId;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.Append("        public ref readonly ").Append(table.StructName).AppendLine(" Value");
            sb.AppendLine("        {");
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            get => ref _table.FindById(_rowId);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.Append("        public ref readonly ").Append(subtableParentTable.StructName).AppendLine(" Parent");
            sb.AppendLine("        {");
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            get => ref _parentTable.FindById(_parentId);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.AppendLine("    public readonly struct ParentScopedRange");
            sb.AppendLine("    {");
            sb.Append("        private readonly TableAccessor<").Append(table.StructName).AppendLine("> _table;");
            sb.AppendLine("        private readonly TableAccessor<int> _rows;");
            sb.AppendLine("        private readonly int _start;");
            sb.AppendLine("        private readonly int _count;");
            sb.AppendLine();
            sb.Append("        internal ParentScopedRange(TableAccessor<").Append(table.StructName).AppendLine("> table, TableAccessor<int> rows, int start, int count)");
            sb.AppendLine("        {");
            sb.AppendLine("            _table = table;");
            sb.AppendLine("            _rows = rows;");
            sb.AppendLine("            _start = start;");
            sb.AppendLine("            _count = count;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        public int Count => _count;");
            sb.AppendLine("        public Enumerator GetEnumerator() => new Enumerator(_table, _rows, _start, _count);");
            sb.AppendLine();
            sb.AppendLine("        public struct Enumerator");
            sb.AppendLine("        {");
            sb.Append("            private readonly TableAccessor<").Append(table.StructName).AppendLine("> _table;");
            sb.AppendLine("            private readonly TableAccessor<int> _rows;");
            sb.AppendLine("            private readonly int _end;");
            sb.AppendLine("            private int _i;");
            sb.AppendLine();
            sb.Append("            internal Enumerator(TableAccessor<").Append(table.StructName).AppendLine("> table, TableAccessor<int> rows, int start, int count)");
            sb.AppendLine("            {");
            sb.AppendLine("                _table = table;");
            sb.AppendLine("                _rows = rows;");
            sb.AppendLine("                _i = start - 1;");
            sb.AppendLine("                _end = start + count;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            public bool MoveNext()");
            sb.AppendLine("            {");
            sb.AppendLine("                _i++;");
            sb.AppendLine("                return _i < _end;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.Append("            public ref readonly ").Append(table.StructName).AppendLine(" Current");
            sb.AppendLine("            {");
            sb.AppendLine("                [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("                get");
            sb.AppendLine("                {");
            sb.AppendLine("                    int rowIndex = _rows.GetAtIndex(_i);");
            sb.AppendLine("                    return ref _table.GetAtIndex(rowIndex);");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        if (table.SubtableChildren.Count > 0 && hasPk)
        {
            sb.AppendLine("    public ParentRowScope FindByIdView(int id)");
            sb.AppendLine("    {");
            sb.AppendLine("        return new ParentRowScope(this, id);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    public ParentRowScope ViewById(int id)");
            sb.AppendLine("    {");
            sb.AppendLine("        return new ParentRowScope(this, id);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    public readonly struct ParentRowScope");
            sb.AppendLine("    {");
            sb.Append("        private readonly ").Append(table.StructName).AppendLine("Table _table;");
            sb.AppendLine("        private readonly int _id;");
            sb.AppendLine();
            sb.Append("        internal ParentRowScope(").Append(table.StructName).AppendLine("Table table, int id)");
            sb.AppendLine("        {");
            sb.AppendLine("            _table = table;");
            sb.AppendLine("            _id = id;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.Append("        public ref readonly ").Append(table.StructName).AppendLine(" Value");
            sb.AppendLine("        {");
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            get => ref _table.FindById(_id);");
            sb.AppendLine("        }");
            sb.AppendLine();
            for (int linkIndex = 0; linkIndex < table.SubtableChildren.Count; linkIndex++)
            {
                ExportSubtableLinkModel link = table.SubtableChildren[linkIndex];
                sb.Append("        public ").Append(link.ChildTable.StructName).Append("Table.ParentScope ").Append(link.PropertyName).AppendLine();
                sb.AppendLine("        {");
                sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append("            get => _table._subtable").Append(link.PropertyName).Append(".ScopeByParent(_id, _table);").AppendLine();
                sb.AppendLine("        }");
                sb.AppendLine();
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    public readonly struct MatchRange");
        sb.AppendLine("    {");
        sb.Append("        private readonly TableAccessor<").Append(table.StructName).AppendLine("> _table;");
        sb.AppendLine("        private readonly TableAccessor<DerpDocKeyRowIndexPair> _pairs;");
        sb.AppendLine("        private readonly int _start;");
        sb.AppendLine("        private readonly int _count;");
        sb.AppendLine();
        sb.Append("        internal MatchRange(TableAccessor<").Append(table.StructName).AppendLine("> table, TableAccessor<DerpDocKeyRowIndexPair> pairs, int start, int count)");
        sb.AppendLine("        {");
        sb.AppendLine("            _table = table;");
        sb.AppendLine("            _pairs = pairs;");
        sb.AppendLine("            _start = start;");
        sb.AppendLine("            _count = count;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public int Count => _count;");
        sb.AppendLine();
        sb.AppendLine("        public Enumerator GetEnumerator() => new Enumerator(_table, _pairs, _start, _count);");
        sb.AppendLine();
        sb.AppendLine("        public struct Enumerator");
        sb.AppendLine("        {");
        sb.Append("            private readonly TableAccessor<").Append(table.StructName).AppendLine("> _table;");
        sb.AppendLine("            private readonly TableAccessor<DerpDocKeyRowIndexPair> _pairs;");
        sb.AppendLine("            private readonly int _end;");
        sb.AppendLine("            private int _i;");
        sb.AppendLine();
        sb.Append("            internal Enumerator(TableAccessor<").Append(table.StructName).AppendLine("> table, TableAccessor<DerpDocKeyRowIndexPair> pairs, int start, int count)");
        sb.AppendLine("            {");
        sb.AppendLine("                _table = table;");
        sb.AppendLine("                _pairs = pairs;");
        sb.AppendLine("                _i = start - 1;");
        sb.AppendLine("                _end = start + count;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            public bool MoveNext()");
        sb.AppendLine("            {");
        sb.AppendLine("                _i++;");
        sb.AppendLine("                return _i < _end;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.Append("            public ref readonly ").Append(table.StructName).AppendLine(" Current");
        sb.AppendLine("            {");
        sb.AppendLine("                [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("                get");
        sb.AppendLine("                {");
        sb.AppendLine("                    int rowIndex = _pairs.GetAtIndex(_i).RowIndex;");
        sb.AppendLine("                    return ref _table.GetAtIndex(rowIndex);");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    private static int LowerBound(ReadOnlySpan<DerpDocKeyRowIndexPair> pairs, int key)");
        sb.AppendLine("    {");
        sb.AppendLine("        int lo = 0;");
        sb.AppendLine("        int hi = pairs.Length;");
        sb.AppendLine("        while (lo < hi)");
        sb.AppendLine("        {");
        sb.AppendLine("            int mid = lo + ((hi - lo) >> 1);");
        sb.AppendLine("            if (pairs[mid].Key < key) lo = mid + 1;");
        sb.AppendLine("            else hi = mid;");
        sb.AppendLine("        }");
        sb.AppendLine("        return lo;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    private static int UpperBound(ReadOnlySpan<DerpDocKeyRowIndexPair> pairs, int key)");
        sb.AppendLine("    {");
        sb.AppendLine("        int lo = 0;");
        sb.AppendLine("        int hi = pairs.Length;");
        sb.AppendLine("        while (lo < hi)");
        sb.AppendLine("        {");
        sb.AppendLine("            int mid = lo + ((hi - lo) >> 1);");
        sb.AppendLine("            if (pairs[mid].Key <= key) lo = mid + 1;");
        sb.AppendLine("            else hi = mid;");
        sb.AppendLine("        }");
        sb.AppendLine("        return lo;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    private static int UpperBoundExact(ReadOnlySpan<DerpDocKeyRowIndexPair> pairs, int key)");
        sb.AppendLine("    {");
        sb.AppendLine("        return UpperBound(pairs, key);");
        sb.AppendLine("    }");

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string RenderTableRuntime(
        string ns,
        ExportTableModel table,
        List<ExportTableModel> allTables,
        int currentTableIndex)
    {
        var sb = new StringBuilder(8192);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();

        string runtimeName = table.StructName + "Runtime";
        string instanceName = table.StructName + "Instance";
        string variablesName = table.StructName + "Variables";
        string linksName = table.StructName + "Links";
        string viewName = table.StructName + "View";
        string slotsName = table.StructName + "VariableSlots";

        var variableIndexByName = new Dictionary<string, int>(table.Variables.Count, StringComparer.OrdinalIgnoreCase);
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            variableIndexByName[table.Variables[variableIndex].Name] = variableIndex;
        }

        var expressionModels = new RuntimeVariableExpressionModel[table.Variables.Count];
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            expressionModels[variableIndex] = BuildRuntimeVariableExpressionModel(
                table.Variables[variableIndex],
                variableIndexByName,
                allTables,
                currentTableIndex);
        }

        var linkedTableIndices = new List<int>(Math.Max(0, allTables.Count - 1));
        for (int tableIndex = 0; tableIndex < allTables.Count; tableIndex++)
        {
            if (tableIndex == currentTableIndex)
            {
                continue;
            }

            linkedTableIndices.Add(tableIndex);
        }

        var bindingExpressionModels = new RuntimeVariableExpressionModel[table.ViewBindings.Count];
        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            DocColumnKind bindingValueKind = ResolveBindingValueKind(binding.TargetKind);
            bindingExpressionModels[bindingIndex] = BuildRuntimeExpressionModel(
                binding.Expression,
                bindingValueKind,
                variableIndexByName,
                allTables,
                currentTableIndex);
        }

        var computedVariableIndices = new List<int>(table.Variables.Count);
        var computedNodeByVariableIndex = new Dictionary<int, int>();
        var isComputedVariable = new bool[table.Variables.Count];
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            if (!table.Variables[variableIndex].HasExpression ||
                expressionModels[variableIndex].Kind == RuntimeVariableExpressionKind.None ||
                expressionModels[variableIndex].Kind == RuntimeVariableExpressionKind.Unsupported)
            {
                continue;
            }

            computedNodeByVariableIndex[variableIndex] = computedVariableIndices.Count;
            computedVariableIndices.Add(variableIndex);
            isComputedVariable[variableIndex] = true;
        }

        var slotDependents = new List<int>[table.Variables.Count];
        for (int slotIndex = 0; slotIndex < slotDependents.Length; slotIndex++)
        {
            slotDependents[slotIndex] = new List<int>(2);
        }

        var computedDependents = new List<int>[computedVariableIndices.Count];
        for (int computedIndex = 0; computedIndex < computedDependents.Length; computedIndex++)
        {
            computedDependents[computedIndex] = new List<int>(2);
        }

        var slotBindingDependents = new List<int>[table.Variables.Count];
        for (int slotIndex = 0; slotIndex < slotBindingDependents.Length; slotIndex++)
        {
            slotBindingDependents[slotIndex] = new List<int>(2);
        }

        for (int computedIndex = 0; computedIndex < computedVariableIndices.Count; computedIndex++)
        {
            int variableIndex = computedVariableIndices[computedIndex];
            var expressionModel = expressionModels[variableIndex];
            if (expressionModel.Kind != RuntimeVariableExpressionKind.ThisTableVariable ||
                expressionModel.ReferencedVariableIndex < 0)
            {
                continue;
            }

            int dependencySlot = expressionModel.ReferencedVariableIndex;
            slotDependents[dependencySlot].Add(computedIndex);

            if (computedNodeByVariableIndex.TryGetValue(dependencySlot, out int dependencyComputedNode))
            {
                computedDependents[dependencyComputedNode].Add(computedIndex);
            }
        }

        for (int bindingIndex = 0; bindingIndex < bindingExpressionModels.Length; bindingIndex++)
        {
            RuntimeVariableExpressionModel bindingExpressionModel = bindingExpressionModels[bindingIndex];
            if (bindingExpressionModel.Kind != RuntimeVariableExpressionKind.ThisTableVariable ||
                bindingExpressionModel.ReferencedVariableIndex < 0)
            {
                continue;
            }

            slotBindingDependents[bindingExpressionModel.ReferencedVariableIndex].Add(bindingIndex);
        }

        sb.Append("public sealed class ").Append(runtimeName).AppendLine();
        sb.AppendLine("{");
        sb.Append("    private readonly ").Append(table.StructName).AppendLine("Table _table;");
        sb.AppendLine("    private readonly List<InstanceState> _instanceStates = new();");
        sb.AppendLine("    private int _stateVersion = 1;");
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            string linkedRuntimeFieldName = BuildRuntimeFieldName(linkedTable.DbPropertyName);
            sb.Append("    private ").Append(linkedTable.StructName).Append("Runtime ").Append(linkedRuntimeFieldName).AppendLine(" = null!;");
        }
        sb.Append("    private const int ComputedNodeCount = ").Append(computedVariableIndices.Count.ToString(CultureInfo.InvariantCulture)).AppendLine(";");
        sb.Append("    private const int BindingNodeCount = ").Append(table.ViewBindings.Count.ToString(CultureInfo.InvariantCulture)).AppendLine(";");
        sb.AppendLine("    private static readonly int[] SlotComputedStarts = " + RenderFlattenedStarts(slotDependents) + ";");
        sb.AppendLine("    private static readonly int[] SlotComputedIndices = " + RenderFlattenedIndices(slotDependents) + ";");
        sb.AppendLine("    private static readonly int[] ComputedDependentStarts = " + RenderFlattenedStarts(computedDependents) + ";");
        sb.AppendLine("    private static readonly int[] ComputedDependentIndices = " + RenderFlattenedIndices(computedDependents) + ";");
        sb.AppendLine("    private static readonly int[] SlotBindingStarts = " + RenderFlattenedStarts(slotBindingDependents) + ";");
        sb.AppendLine("    private static readonly int[] SlotBindingIndices = " + RenderFlattenedIndices(slotBindingDependents) + ";");
        sb.AppendLine();
        sb.Append("    internal ").Append(runtimeName).Append("(").Append(table.StructName).AppendLine("Table table)");
        sb.AppendLine("    {");
        sb.AppendLine("        _table = table;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.Append("    internal void ConnectRuntimes(");
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            if (linkedIndex > 0)
            {
                sb.Append(", ");
            }

            string paramName = char.ToLowerInvariant(linkedTable.DbPropertyName[0]) + linkedTable.DbPropertyName.Substring(1) + "Runtime";
            sb.Append(linkedTable.StructName).Append("Runtime ").Append(paramName);
        }
        sb.AppendLine(")");
        sb.AppendLine("    {");
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            string linkedRuntimeFieldName = BuildRuntimeFieldName(linkedTable.DbPropertyName);
            string paramName = char.ToLowerInvariant(linkedTable.DbPropertyName[0]) + linkedTable.DbPropertyName.Substring(1) + "Runtime";
            sb.Append("        ").Append(linkedRuntimeFieldName).Append(" = ").Append(paramName).AppendLine(";");
        }
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.Append("    public ").Append(table.StructName).AppendLine("Table Table => _table;");
        sb.AppendLine("    public int Version => _stateVersion;");
        sb.AppendLine("    public int InstanceCount => _instanceStates.Count;");
        sb.AppendLine();
        sb.Append("    public ").Append(instanceName).AppendLine(" CreateInstance()");
        sb.AppendLine("    {");
        sb.AppendLine("        var state = new InstanceState();");
        sb.AppendLine("        state.ResetVariableDefaults();");
        sb.AppendLine("        state.ResetLinkDefaults();");
        sb.AppendLine("        _instanceStates.Add(state);");
        sb.AppendLine("        int instanceId = _instanceStates.Count - 1;");
        sb.AppendLine("        RecomputeAllComputedVariables(instanceId);");
        sb.AppendLine("        RecomputeAllBindings(instanceId);");
        sb.AppendLine("        BumpVersion();");
        sb.Append("        return new ").Append(instanceName).AppendLine("(this, instanceId);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.Append("    public ").Append(instanceName).AppendLine(" GetInstance(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        ValidateInstanceId(instanceId);");
        sb.Append("        return new ").Append(instanceName).AppendLine("(this, instanceId);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    internal void ResetVariables(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        ref var state = ref GetStateRef(instanceId);");
        sb.AppendLine("        state.ResetVariableDefaults();");
        sb.AppendLine("        RecomputeAllComputedVariables(instanceId);");
        sb.AppendLine("        RecomputeAllBindings(instanceId);");
        sb.AppendLine("        BumpVersion();");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool RecomputeAllComputedVariables(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ComputedNodeCount <= 0)");
        sb.AppendLine("        {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        bool anyChanged = false;");
        sb.AppendLine("        for (int passIndex = 0; passIndex < ComputedNodeCount; passIndex++)");
        sb.AppendLine("        {");
        sb.AppendLine("            bool passChanged = false;");
        sb.AppendLine("            for (int nodeIndex = 0; nodeIndex < ComputedNodeCount; nodeIndex++)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (EvaluateComputedNode(instanceId, nodeIndex))");
        sb.AppendLine("                {");
        sb.AppendLine("                    passChanged = true;");
        sb.AppendLine("                    anyChanged = true;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            if (!passChanged)");
        sb.AppendLine("            {");
        sb.AppendLine("                break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return anyChanged;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool RecomputeFromChangedSlot(int instanceId, int slotIndex)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ComputedNodeCount <= 0 || (uint)slotIndex >= (uint)SlotComputedStarts.Length - 1)");
        sb.AppendLine("        {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        Span<int> queue = stackalloc int[ComputedNodeCount];");
        sb.AppendLine("        Span<byte> queued = stackalloc byte[ComputedNodeCount];");
        sb.AppendLine("        int head = 0;");
        sb.AppendLine("        int tail = 0;");
        sb.AppendLine();
        sb.AppendLine("        int rootsStart = SlotComputedStarts[slotIndex];");
        sb.AppendLine("        int rootsEnd = SlotComputedStarts[slotIndex + 1];");
        sb.AppendLine("        for (int rootIndex = rootsStart; rootIndex < rootsEnd; rootIndex++)");
        sb.AppendLine("        {");
        sb.AppendLine("            int nodeIndex = SlotComputedIndices[rootIndex];");
        sb.AppendLine("            if (queued[nodeIndex] != 0)");
        sb.AppendLine("            {");
        sb.AppendLine("                continue;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            queued[nodeIndex] = 1;");
        sb.AppendLine("            queue[tail] = nodeIndex;");
        sb.AppendLine("            tail++;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        bool anyChanged = false;");
        sb.AppendLine("        while (head < tail)");
        sb.AppendLine("        {");
        sb.AppendLine("            int nodeIndex = queue[head];");
        sb.AppendLine("            head++;");
        sb.AppendLine("            queued[nodeIndex] = 0;");
        sb.AppendLine();
        sb.AppendLine("            if (!EvaluateComputedNode(instanceId, nodeIndex))");
        sb.AppendLine("            {");
        sb.AppendLine("                continue;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            anyChanged = true;");
        sb.AppendLine("            int dependentStart = ComputedDependentStarts[nodeIndex];");
        sb.AppendLine("            int dependentEnd = ComputedDependentStarts[nodeIndex + 1];");
        sb.AppendLine("            for (int dependentIndex = dependentStart; dependentIndex < dependentEnd; dependentIndex++)");
        sb.AppendLine("            {");
        sb.AppendLine("                int downstreamNodeIndex = ComputedDependentIndices[dependentIndex];");
        sb.AppendLine("                if (queued[downstreamNodeIndex] != 0)");
        sb.AppendLine("                {");
        sb.AppendLine("                    continue;");
        sb.AppendLine("                }");
        sb.AppendLine();
        sb.AppendLine("                queued[downstreamNodeIndex] = 1;");
        sb.AppendLine("                queue[tail] = downstreamNodeIndex;");
        sb.AppendLine("                tail++;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return anyChanged;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool RecomputeAllBindings(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (BindingNodeCount <= 0)");
        sb.AppendLine("        {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        bool anyChanged = false;");
        sb.AppendLine("        for (int bindingIndex = 0; bindingIndex < BindingNodeCount; bindingIndex++)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (EvaluateBindingNode(instanceId, bindingIndex))");
        sb.AppendLine("            {");
        sb.AppendLine("                anyChanged = true;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return anyChanged;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool RecomputeBindingsFromChangedSlot(int instanceId, int slotIndex)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (BindingNodeCount <= 0 || (uint)slotIndex >= (uint)SlotBindingStarts.Length - 1)");
        sb.AppendLine("        {");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        bool anyChanged = false;");
        sb.AppendLine("        int start = SlotBindingStarts[slotIndex];");
        sb.AppendLine("        int end = SlotBindingStarts[slotIndex + 1];");
        sb.AppendLine("        for (int index = start; index < end; index++)");
        sb.AppendLine("        {");
        sb.AppendLine("            int bindingIndex = SlotBindingIndices[index];");
        sb.AppendLine("            if (EvaluateBindingNode(instanceId, bindingIndex))");
        sb.AppendLine("            {");
        sb.AppendLine("                anyChanged = true;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return anyChanged;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool EvaluateBindingNode(int instanceId, int bindingIndex)");
        sb.AppendLine("    {");
        sb.AppendLine("        return bindingIndex switch");
        sb.AppendLine("        {");
        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            sb.Append("            ").Append(bindingIndex.ToString(CultureInfo.InvariantCulture)).Append(" => EvaluateBinding").Append(binding.OutputName).AppendLine("(instanceId),");
        }
        sb.AppendLine("            _ => false,");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool EvaluateComputedNode(int instanceId, int nodeIndex)");
        sb.AppendLine("    {");
        sb.AppendLine("        return nodeIndex switch");
        sb.AppendLine("        {");
        for (int computedIndex = 0; computedIndex < computedVariableIndices.Count; computedIndex++)
        {
            int variableIndex = computedVariableIndices[computedIndex];
            string methodName = "EvaluateComputed" + table.Variables[variableIndex].SlotName;
            sb.Append("            ").Append(computedIndex.ToString(CultureInfo.InvariantCulture)).Append(" => ").Append(methodName).AppendLine("(instanceId),");
        }
        sb.AppendLine("            _ => false,");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private ref InstanceState GetStateRef(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        ValidateInstanceId(instanceId);");
        sb.AppendLine("        return ref CollectionsMarshal.AsSpan(_instanceStates)[instanceId];");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private void ValidateInstanceId(int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        if ((uint)instanceId >= (uint)_instanceStates.Count)");
        sb.AppendLine("        {");
        sb.AppendLine("            throw new ArgumentOutOfRangeException(nameof(instanceId));");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();

        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            ExportTableVariableModel variable = table.Variables[variableIndex];
            string variableType = ResolveRuntimeVariableType(variable.Kind);
            string methodSuffix = variable.SlotName;
            sb.Append("    internal ").Append(variableType).Append(" Get").Append(methodSuffix).Append("(int instanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        return GetStateRef(instanceId)." + BuildStateFieldName(variable) + ";");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.Append("    internal void Set").Append(methodSuffix).Append("(int instanceId, ").Append(variableType).Append(" value)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        ref var state = ref GetStateRef(instanceId);");
            if (isComputedVariable[variableIndex])
            {
                string overrideFieldName = BuildOverrideFieldName(variable);
                sb.Append("        bool wasOverride = state.").Append(overrideFieldName).AppendLine(";");
            }
            sb.Append("        if (").Append(BuildValueEqualsExpression(variable, "state." + BuildStateFieldName(variable), "value")).AppendLine(")");
            sb.AppendLine("        {");
            if (isComputedVariable[variableIndex])
            {
                string overrideFieldName = BuildOverrideFieldName(variable);
                sb.AppendLine("            if (wasOverride)");
                sb.AppendLine("            {");
                sb.AppendLine("                return;");
                sb.AppendLine("            }");
                sb.Append("            state.").Append(overrideFieldName).AppendLine(" = true;");
                sb.AppendLine("            BumpVersion();");
                sb.AppendLine("            return;");
            }
            else
            {
                sb.AppendLine("            return;");
            }
            sb.AppendLine("        }");
            sb.Append("        state.").Append(BuildStateFieldName(variable)).AppendLine(" = value;");
            if (isComputedVariable[variableIndex])
            {
                sb.Append("        state.").Append(BuildOverrideFieldName(variable)).AppendLine(" = true;");
            }
            sb.Append("        RecomputeFromChangedSlot(instanceId, ").Append(slotsName).Append('.').Append(methodSuffix).AppendLine(");");
            sb.Append("        RecomputeBindingsFromChangedSlot(instanceId, ").Append(slotsName).Append('.').Append(methodSuffix).AppendLine(");");
            sb.AppendLine("        BumpVersion();");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            string linkMethodSuffix = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(linkedTable.DbPropertyName), "Link");
            string linkFieldName = BuildLinkFieldName(linkedTable.StructName);
            string linkedRuntimeFieldName = BuildRuntimeFieldName(linkedTable.DbPropertyName);

            sb.Append("    internal int GetLink").Append(linkMethodSuffix).Append("(int instanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.Append("        return GetStateRef(instanceId).").Append(linkFieldName).AppendLine(";");
            sb.AppendLine("    }");
            sb.AppendLine();

            sb.Append("    internal void SetLink").Append(linkMethodSuffix).Append("(int instanceId, int linkedInstanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        if (linkedInstanceId < -1)");
            sb.AppendLine("        {");
            sb.AppendLine("            throw new ArgumentOutOfRangeException(nameof(linkedInstanceId));");
            sb.AppendLine("        }");
            sb.Append("        if (linkedInstanceId >= 0 && (uint)linkedInstanceId >= (uint)").Append(linkedRuntimeFieldName).AppendLine(".InstanceCount)");
            sb.AppendLine("        {");
            sb.AppendLine("            throw new ArgumentOutOfRangeException(nameof(linkedInstanceId));");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        ref var state = ref GetStateRef(instanceId);");
            sb.Append("        if (state.").Append(linkFieldName).AppendLine(" == linkedInstanceId)");
            sb.AppendLine("        {");
            sb.AppendLine("            return;");
            sb.AppendLine("        }");
            sb.Append("        state.").Append(linkFieldName).AppendLine(" = linkedInstanceId;");
            sb.AppendLine("        RecomputeAllComputedVariables(instanceId);");
            sb.AppendLine("        RecomputeAllBindings(instanceId);");
            sb.AppendLine("        BumpVersion();");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            string bindingValueType = ResolveBindingRuntimeType(binding.TargetKind);
            string stateFieldName = BuildBindingStateFieldName(binding);
            sb.Append("    internal ").Append(bindingValueType).Append(" GetBinding").Append(binding.OutputName).Append("(int instanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.Append("        return GetStateRef(instanceId).").Append(stateFieldName).AppendLine(";");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        for (int computedIndex = 0; computedIndex < computedVariableIndices.Count; computedIndex++)
        {
            int variableIndex = computedVariableIndices[computedIndex];
            ExportTableVariableModel variable = table.Variables[variableIndex];
            RuntimeVariableExpressionModel expressionModel = expressionModels[variableIndex];
            string variableType = ResolveRuntimeVariableType(variable.Kind);
            string stateFieldName = BuildStateFieldName(variable);

            sb.Append("    private bool EvaluateComputed").Append(variable.SlotName).Append("(int instanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        ref var state = ref GetStateRef(instanceId);");
            sb.Append("        if (state.").Append(BuildOverrideFieldName(variable)).AppendLine(")");
            sb.AppendLine("        {");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.Append("        ").Append(variableType).Append(" nextValue = ").Append(RenderComputedValueExpression(
                variable,
                expressionModel,
                table.Variables,
                allTables)).AppendLine(";");
            sb.Append("        if (").Append(BuildValueEqualsExpression(variable, "state." + stateFieldName, "nextValue")).AppendLine(")");
            sb.AppendLine("        {");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.Append("        state.").Append(stateFieldName).AppendLine(" = nextValue;");
            sb.AppendLine("        return true;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            RuntimeVariableExpressionModel expressionModel = bindingExpressionModels[bindingIndex];
            string bindingValueType = ResolveBindingRuntimeType(binding.TargetKind);
            string stateFieldName = BuildBindingStateFieldName(binding);
            sb.Append("    private bool EvaluateBinding").Append(binding.OutputName).Append("(int instanceId)").AppendLine();
            sb.AppendLine("    {");
            sb.AppendLine("        ref var state = ref GetStateRef(instanceId);");
            sb.Append("        ").Append(bindingValueType).Append(" nextValue = ").Append(RenderBindingValueExpression(
                binding,
                expressionModel,
                table.Variables,
                allTables)).AppendLine(";");
            sb.Append("        if (").Append(BuildBindingEqualsExpression(binding.TargetKind, "state." + stateFieldName, "nextValue")).AppendLine(")");
            sb.AppendLine("        {");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.Append("        state.").Append(stateFieldName).AppendLine(" = nextValue;");
            sb.AppendLine("        return true;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    private void BumpVersion()");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_stateVersion == int.MaxValue)");
        sb.AppendLine("        {");
        sb.AppendLine("            _stateVersion = 1;");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        _stateVersion++;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private struct InstanceState");
        sb.AppendLine("    {");
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            ExportTableVariableModel variable = table.Variables[variableIndex];
            string variableType = ResolveRuntimeVariableType(variable.Kind);
            string stateField = BuildStateFieldName(variable);
            sb.Append("        public ").Append(variableType).Append(' ').Append(stateField).AppendLine(";");
            if (isComputedVariable[variableIndex])
            {
                sb.Append("        public bool ").Append(BuildOverrideFieldName(variable)).AppendLine(";");
            }
        }
        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            sb.Append("        public ").Append(ResolveBindingRuntimeType(binding.TargetKind)).Append(' ').Append(BuildBindingStateFieldName(binding)).AppendLine(";");
        }
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            sb.Append("        public int ").Append(BuildLinkFieldName(linkedTable.StructName)).AppendLine(";");
        }
        sb.AppendLine();
        sb.AppendLine("        public void ResetVariableDefaults()");
        sb.AppendLine("        {");
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            ExportTableVariableModel variable = table.Variables[variableIndex];
            sb.Append("            ").Append(BuildStateFieldName(variable)).Append(" = ").Append(RenderRuntimeDefaultLiteral(variable)).AppendLine(";");
            if (isComputedVariable[variableIndex])
            {
                sb.Append("            ").Append(BuildOverrideFieldName(variable)).AppendLine(" = false;");
            }
        }
        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            sb.Append("            ").Append(BuildBindingStateFieldName(binding)).Append(" = ").Append(RenderBindingDefaultLiteral(binding.TargetKind)).AppendLine(";");
        }
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public void ResetLinkDefaults()");
        sb.AppendLine("        {");
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            sb.Append("            ").Append(BuildLinkFieldName(linkedTable.StructName)).AppendLine(" = -1;");
        }
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.Append("public struct ").Append(instanceName).AppendLine();
        sb.AppendLine("{");
        sb.Append("    private readonly ").Append(runtimeName).AppendLine(" _runtime;");
        sb.AppendLine("    private readonly int _instanceId;");
        sb.Append("    public ").Append(variablesName).AppendLine(" Vars;");
        sb.Append("    public ").Append(linksName).AppendLine(" Links;");
        sb.Append("    public ").Append(viewName).AppendLine(" View;");
        sb.AppendLine();
        sb.Append("    internal ").Append(instanceName).Append("(").Append(runtimeName).AppendLine(" runtime, int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        _runtime = runtime;");
        sb.AppendLine("        _instanceId = instanceId;");
        sb.Append("        Vars = new ").Append(variablesName).AppendLine("(runtime, instanceId);");
        sb.Append("        Links = new ").Append(linksName).AppendLine("(runtime, instanceId);");
        sb.Append("        View = new ").Append(viewName).AppendLine("(runtime, instanceId);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public int Id => _instanceId;");
        sb.AppendLine("    public void ResetVariablesToDefaults() => _runtime.ResetVariables(_instanceId);");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.Append("public readonly struct ").Append(variablesName).AppendLine();
        sb.AppendLine("{");
        sb.Append("    private readonly ").Append(runtimeName).AppendLine(" _runtime;");
        sb.AppendLine("    private readonly int _instanceId;");
        sb.AppendLine();
        sb.Append("    internal ").Append(variablesName).Append("(").Append(runtimeName).AppendLine(" runtime, int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        _runtime = runtime;");
        sb.AppendLine("        _instanceId = instanceId;");
        sb.AppendLine("    }");
        sb.AppendLine();
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            ExportTableVariableModel variable = table.Variables[variableIndex];
            string variableType = ResolveRuntimeVariableType(variable.Kind);
            string propertyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(variable.Name), "Variable");
            string methodSuffix = variable.SlotName;
            sb.Append("    public ").Append(variableType).Append(' ').Append(propertyName).AppendLine();
            sb.AppendLine("    {");
            sb.Append("        get => _runtime.Get").Append(methodSuffix).AppendLine("(_instanceId);");
            sb.Append("        set => _runtime.Set").Append(methodSuffix).AppendLine("(_instanceId, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        sb.AppendLine("}");
        sb.AppendLine();

        sb.Append("public readonly struct ").Append(linksName).AppendLine();
        sb.AppendLine("{");
        sb.Append("    private readonly ").Append(runtimeName).AppendLine(" _runtime;");
        sb.AppendLine("    private readonly int _instanceId;");
        sb.AppendLine();
        sb.Append("    internal ").Append(linksName).Append("(").Append(runtimeName).AppendLine(" runtime, int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        _runtime = runtime;");
        sb.AppendLine("        _instanceId = instanceId;");
        sb.AppendLine("    }");
        sb.AppendLine();
        for (int linkedIndex = 0; linkedIndex < linkedTableIndices.Count; linkedIndex++)
        {
            ExportTableModel linkedTable = allTables[linkedTableIndices[linkedIndex]];
            string linkPropertyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(linkedTable.DbPropertyName), "Link");
            sb.Append("    public int ").Append(linkPropertyName).AppendLine();
            sb.AppendLine("    {");
            sb.Append("        get => _runtime.GetLink").Append(linkPropertyName).AppendLine("(_instanceId);");
            sb.Append("        set => _runtime.SetLink").Append(linkPropertyName).AppendLine("(_instanceId, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
        sb.AppendLine("}");
        sb.AppendLine();

        sb.Append("public readonly struct ").Append(viewName).AppendLine();
        sb.AppendLine("{");
        sb.Append("    private readonly ").Append(runtimeName).AppendLine(" _runtime;");
        sb.AppendLine("    private readonly int _instanceId;");
        sb.AppendLine();
        sb.Append("    internal ").Append(viewName).Append("(").Append(runtimeName).AppendLine(" runtime, int instanceId)");
        sb.AppendLine("    {");
        sb.AppendLine("        _runtime = runtime;");
        sb.AppendLine("        _instanceId = instanceId;");
        sb.AppendLine("    }");
        sb.AppendLine();
        for (int bindingIndex = 0; bindingIndex < table.ViewBindings.Count; bindingIndex++)
        {
            ExportViewBindingModel binding = table.ViewBindings[bindingIndex];
            sb.Append("    public ").Append(ResolveBindingRuntimeType(binding.TargetKind)).Append(' ').Append(binding.OutputName)
                .Append(" => _runtime.GetBinding").Append(binding.OutputName).AppendLine("(_instanceId);");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        sb.Append("public static class ").Append(slotsName).AppendLine();
        sb.AppendLine("{");
        for (int variableIndex = 0; variableIndex < table.Variables.Count; variableIndex++)
        {
            ExportTableVariableModel variable = table.Variables[variableIndex];
            sb.Append("    public const int ").Append(variable.SlotName).Append(" = ").Append(variableIndex.ToString(CultureInfo.InvariantCulture)).AppendLine(";");
        }
        sb.Append("    public const int Count = ").Append(table.Variables.Count.ToString(CultureInfo.InvariantCulture)).AppendLine(";");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private enum RuntimeVariableExpressionKind
    {
        None,
        NumberLiteral,
        BoolLiteral,
        StringLiteral,
        ThisTableVariable,
        CrossTableVariable,
        Unsupported,
    }

    private readonly struct RuntimeVariableExpressionModel
    {
        public RuntimeVariableExpressionModel(
            RuntimeVariableExpressionKind kind,
            int referencedTableIndex,
            int referencedVariableIndex,
            double numberLiteral,
            bool boolLiteral,
            string stringLiteral)
        {
            Kind = kind;
            ReferencedTableIndex = referencedTableIndex;
            ReferencedVariableIndex = referencedVariableIndex;
            NumberLiteral = numberLiteral;
            BoolLiteral = boolLiteral;
            StringLiteral = stringLiteral;
        }

        public RuntimeVariableExpressionKind Kind { get; }
        public int ReferencedTableIndex { get; }
        public int ReferencedVariableIndex { get; }
        public double NumberLiteral { get; }
        public bool BoolLiteral { get; }
        public string StringLiteral { get; }
    }

    private static RuntimeVariableExpressionModel BuildRuntimeVariableExpressionModel(
        ExportTableVariableModel variable,
        Dictionary<string, int> variableIndexByName,
        List<ExportTableModel> allTables,
        int currentTableIndex)
    {
        return BuildRuntimeExpressionModel(
            variable.Expression,
            variable.Kind,
            variableIndexByName,
            allTables,
            currentTableIndex);
    }

    private static RuntimeVariableExpressionModel BuildRuntimeExpressionModel(
        string rawExpression,
        DocColumnKind expectedKind,
        Dictionary<string, int> variableIndexByName,
        List<ExportTableModel> allTables,
        int currentTableIndex)
    {
        string expression = rawExpression.Trim();
        if (expression.Length <= 0)
        {
            return new RuntimeVariableExpressionModel(
                RuntimeVariableExpressionKind.None,
                referencedTableIndex: -1,
                referencedVariableIndex: -1,
                numberLiteral: 0d,
                boolLiteral: false,
                stringLiteral: "");
        }

        if (expectedKind == DocColumnKind.Number &&
            double.TryParse(expression, NumberStyles.Float, CultureInfo.InvariantCulture, out double parsedNumber))
        {
            return new RuntimeVariableExpressionModel(
                RuntimeVariableExpressionKind.NumberLiteral,
                referencedTableIndex: -1,
                referencedVariableIndex: -1,
                numberLiteral: parsedNumber,
                boolLiteral: false,
                stringLiteral: "");
        }

        if (expectedKind == DocColumnKind.Checkbox)
        {
            if (string.Equals(expression, "true", StringComparison.OrdinalIgnoreCase))
            {
                return new RuntimeVariableExpressionModel(
                    RuntimeVariableExpressionKind.BoolLiteral,
                    referencedTableIndex: -1,
                    referencedVariableIndex: -1,
                    numberLiteral: 0d,
                    boolLiteral: true,
                    stringLiteral: "");
            }

            if (string.Equals(expression, "false", StringComparison.OrdinalIgnoreCase))
            {
                return new RuntimeVariableExpressionModel(
                    RuntimeVariableExpressionKind.BoolLiteral,
                    referencedTableIndex: -1,
                    referencedVariableIndex: -1,
                    numberLiteral: 0d,
                    boolLiteral: false,
                stringLiteral: "");
            }
        }

        if ((expectedKind == DocColumnKind.Text ||
             expectedKind == DocColumnKind.Select ||
             expectedKind == DocColumnKind.Relation ||
             expectedKind == DocColumnKind.TextureAsset ||
             expectedKind == DocColumnKind.MeshAsset ||
             expectedKind == DocColumnKind.AudioAsset ||
             expectedKind == DocColumnKind.UiAsset) &&
            TryParseQuotedStringLiteral(expression, out string parsedString))
        {
            return new RuntimeVariableExpressionModel(
                RuntimeVariableExpressionKind.StringLiteral,
                referencedTableIndex: -1,
                referencedVariableIndex: -1,
                numberLiteral: 0d,
                boolLiteral: false,
                stringLiteral: parsedString);
        }

        const string thisTablePrefix = "thisTable.";
        if (expression.StartsWith(thisTablePrefix, StringComparison.OrdinalIgnoreCase))
        {
            string variableName = expression.Substring(thisTablePrefix.Length).Trim();
            if (variableName.Length > 0 &&
                variableIndexByName.TryGetValue(variableName, out int referencedVariableIndex))
            {
                return new RuntimeVariableExpressionModel(
                    RuntimeVariableExpressionKind.ThisTableVariable,
                    referencedTableIndex: currentTableIndex,
                    referencedVariableIndex,
                    numberLiteral: 0d,
                    boolLiteral: false,
                    stringLiteral: "");
            }
        }

        const string tablesPrefix = "tables.";
        if (expression.StartsWith(tablesPrefix, StringComparison.OrdinalIgnoreCase))
        {
            string reference = expression.Substring(tablesPrefix.Length);
            int separatorIndex = reference.IndexOf('.');
            if (separatorIndex > 0 && separatorIndex < reference.Length - 1)
            {
                string tableName = reference.Substring(0, separatorIndex).Trim();
                string variableName = reference.Substring(separatorIndex + 1).Trim();
                int referencedTableIndex = FindExportTableIndexByName(allTables, tableName);
                if (referencedTableIndex >= 0 && variableName.Length > 0)
                {
                    ExportTableModel referencedTable = allTables[referencedTableIndex];
                    int referencedVariableIndex = FindVariableIndexByName(referencedTable.Variables, variableName);
                    if (referencedVariableIndex >= 0)
                    {
                        if (referencedTableIndex == currentTableIndex)
                        {
                            return new RuntimeVariableExpressionModel(
                                RuntimeVariableExpressionKind.ThisTableVariable,
                                referencedTableIndex,
                                referencedVariableIndex,
                                numberLiteral: 0d,
                                boolLiteral: false,
                                stringLiteral: "");
                        }

                        return new RuntimeVariableExpressionModel(
                            RuntimeVariableExpressionKind.CrossTableVariable,
                            referencedTableIndex,
                            referencedVariableIndex,
                            numberLiteral: 0d,
                            boolLiteral: false,
                            stringLiteral: "");
                    }
                }
            }
        }

        return new RuntimeVariableExpressionModel(
            RuntimeVariableExpressionKind.Unsupported,
            referencedTableIndex: -1,
            referencedVariableIndex: -1,
            numberLiteral: 0d,
            boolLiteral: false,
            stringLiteral: "");
    }

    private static string RenderComputedValueExpression(
        ExportTableVariableModel variable,
        RuntimeVariableExpressionModel expressionModel,
        List<ExportTableVariableModel> variables,
        List<ExportTableModel> allTables)
    {
        if (expressionModel.Kind == RuntimeVariableExpressionKind.NumberLiteral)
        {
            return expressionModel.NumberLiteral.ToString("R", CultureInfo.InvariantCulture) + "d";
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.BoolLiteral)
        {
            return expressionModel.BoolLiteral ? "true" : "false";
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.StringLiteral)
        {
            return QuoteStringLiteral(expressionModel.StringLiteral);
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.ThisTableVariable &&
            (uint)expressionModel.ReferencedVariableIndex < (uint)variables.Count)
        {
            ExportTableVariableModel referencedVariable = variables[expressionModel.ReferencedVariableIndex];
            return "state." + BuildStateFieldName(referencedVariable);
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.CrossTableVariable &&
            (uint)expressionModel.ReferencedTableIndex < (uint)allTables.Count)
        {
            ExportTableModel targetTable = allTables[expressionModel.ReferencedTableIndex];
            if ((uint)expressionModel.ReferencedVariableIndex < (uint)targetTable.Variables.Count)
            {
                ExportTableVariableModel targetVariable = targetTable.Variables[expressionModel.ReferencedVariableIndex];
                string linkFieldName = BuildLinkFieldName(targetTable.StructName);
                string runtimeFieldName = BuildRuntimeFieldName(targetTable.DbPropertyName);
                string getMethodName = "Get" + targetVariable.SlotName;
                string fallback = RenderRuntimeDefaultLiteral(variable);
                return "(state." + linkFieldName +
                    " >= 0 && (uint)state." + linkFieldName +
                    " < (uint)" + runtimeFieldName + ".InstanceCount ? " +
                    runtimeFieldName + "." + getMethodName + "(state." + linkFieldName + ") : " + fallback + ")";
            }
        }

        return RenderRuntimeDefaultLiteral(variable);
    }

    private static DocColumnKind ResolveBindingValueKind(ExportViewBindingTargetKind targetKind)
    {
        if (targetKind == ExportViewBindingTargetKind.SortDescending)
        {
            return DocColumnKind.Checkbox;
        }

        return DocColumnKind.Text;
    }

    private static string ResolveBindingRuntimeType(ExportViewBindingTargetKind targetKind)
    {
        return ResolveBindingValueKind(targetKind) == DocColumnKind.Checkbox
            ? "bool"
            : "string";
    }

    private static string BuildBindingStateFieldName(ExportViewBindingModel binding)
    {
        return "_binding" + binding.OutputName;
    }

    private static string RenderBindingDefaultLiteral(ExportViewBindingTargetKind targetKind)
    {
        return ResolveBindingValueKind(targetKind) == DocColumnKind.Checkbox
            ? "false"
            : "\"\"";
    }

    private static string BuildBindingEqualsExpression(ExportViewBindingTargetKind targetKind, string currentValueExpression, string newValueExpression)
    {
        if (ResolveBindingValueKind(targetKind) == DocColumnKind.Checkbox)
        {
            return currentValueExpression + " == " + newValueExpression;
        }

        return "string.Equals(" + currentValueExpression + ", " + newValueExpression + ", StringComparison.Ordinal)";
    }

    private static string RenderBindingValueExpression(
        ExportViewBindingModel binding,
        RuntimeVariableExpressionModel expressionModel,
        List<ExportTableVariableModel> sourceVariables,
        List<ExportTableModel> allTables)
    {
        DocColumnKind expectedKind = ResolveBindingValueKind(binding.TargetKind);
        if (expectedKind == DocColumnKind.Checkbox &&
            expressionModel.Kind == RuntimeVariableExpressionKind.BoolLiteral)
        {
            return expressionModel.BoolLiteral ? "true" : "false";
        }

        if (expectedKind != DocColumnKind.Checkbox &&
            expressionModel.Kind == RuntimeVariableExpressionKind.StringLiteral)
        {
            return QuoteStringLiteral(expressionModel.StringLiteral);
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.ThisTableVariable &&
            (uint)expressionModel.ReferencedVariableIndex < (uint)sourceVariables.Count)
        {
            ExportTableVariableModel variable = sourceVariables[expressionModel.ReferencedVariableIndex];
            if (expectedKind == DocColumnKind.Checkbox && variable.Kind == DocColumnKind.Checkbox)
            {
                return "state." + BuildStateFieldName(variable);
            }

            if (expectedKind != DocColumnKind.Checkbox &&
                IsStringRuntimeKind(variable.Kind))
            {
                return "state." + BuildStateFieldName(variable);
            }
        }

        if (expressionModel.Kind == RuntimeVariableExpressionKind.CrossTableVariable &&
            (uint)expressionModel.ReferencedTableIndex < (uint)allTables.Count)
        {
            ExportTableModel targetTable = allTables[expressionModel.ReferencedTableIndex];
            if ((uint)expressionModel.ReferencedVariableIndex < (uint)targetTable.Variables.Count)
            {
                ExportTableVariableModel variable = targetTable.Variables[expressionModel.ReferencedVariableIndex];
                string linkFieldName = BuildLinkFieldName(targetTable.StructName);
                string runtimeFieldName = BuildRuntimeFieldName(targetTable.DbPropertyName);
                string getterName = "Get" + variable.SlotName;
                string fallback = RenderBindingDefaultLiteral(binding.TargetKind);

                if (expectedKind == DocColumnKind.Checkbox && variable.Kind == DocColumnKind.Checkbox)
                {
                    return "(state." + linkFieldName +
                        " >= 0 && (uint)state." + linkFieldName +
                        " < (uint)" + runtimeFieldName + ".InstanceCount ? " +
                        runtimeFieldName + "." + getterName + "(state." + linkFieldName + ") : " + fallback + ")";
                }

                if (expectedKind != DocColumnKind.Checkbox &&
                    IsStringRuntimeKind(variable.Kind))
                {
                    return "(state." + linkFieldName +
                        " >= 0 && (uint)state." + linkFieldName +
                        " < (uint)" + runtimeFieldName + ".InstanceCount ? " +
                        runtimeFieldName + "." + getterName + "(state." + linkFieldName + ") : " + fallback + ")";
                }
            }
        }

        return RenderBindingDefaultLiteral(binding.TargetKind);
    }

    private static bool IsStringRuntimeKind(DocColumnKind kind)
    {
        if (kind == DocColumnKind.Number || kind == DocColumnKind.Checkbox)
        {
            return false;
        }

        return true;
    }

    private static string RenderFlattenedStarts(List<int>[] dependents)
    {
        var values = new List<int>(dependents.Length + 1);
        int runningIndex = 0;
        values.Add(0);
        for (int listIndex = 0; listIndex < dependents.Length; listIndex++)
        {
            runningIndex += dependents[listIndex].Count;
            values.Add(runningIndex);
        }

        return RenderIntArrayLiteral(values);
    }

    private static string RenderFlattenedIndices(List<int>[] dependents)
    {
        int count = 0;
        for (int listIndex = 0; listIndex < dependents.Length; listIndex++)
        {
            count += dependents[listIndex].Count;
        }

        var values = new List<int>(count);
        for (int listIndex = 0; listIndex < dependents.Length; listIndex++)
        {
            List<int> nodes = dependents[listIndex];
            for (int nodeIndex = 0; nodeIndex < nodes.Count; nodeIndex++)
            {
                values.Add(nodes[nodeIndex]);
            }
        }

        return RenderIntArrayLiteral(values);
    }

    private static string RenderIntArrayLiteral(List<int> values)
    {
        if (values.Count <= 0)
        {
            return "Array.Empty<int>()";
        }

        var sb = new StringBuilder(values.Count * 4 + 16);
        sb.Append("new int[] { ");
        for (int valueIndex = 0; valueIndex < values.Count; valueIndex++)
        {
            if (valueIndex > 0)
            {
                sb.Append(", ");
            }

            sb.Append(values[valueIndex].ToString(CultureInfo.InvariantCulture));
        }

        sb.Append(" }");
        return sb.ToString();
    }

    private static int FindExportTableIndexByName(List<ExportTableModel> allTables, string tableName)
    {
        for (int tableIndex = 0; tableIndex < allTables.Count; tableIndex++)
        {
            ExportTableModel table = allTables[tableIndex];
            if (string.Equals(table.Table.Name, tableName, StringComparison.OrdinalIgnoreCase) ||
                string.Equals(table.StructName, tableName, StringComparison.OrdinalIgnoreCase) ||
                string.Equals(table.DbPropertyName, tableName, StringComparison.OrdinalIgnoreCase))
            {
                return tableIndex;
            }
        }

        return -1;
    }

    private static int FindVariableIndexByName(List<ExportTableVariableModel> variables, string variableName)
    {
        for (int variableIndex = 0; variableIndex < variables.Count; variableIndex++)
        {
            if (string.Equals(variables[variableIndex].Name, variableName, StringComparison.OrdinalIgnoreCase))
            {
                return variableIndex;
            }
        }

        return -1;
    }

    private static string BuildRuntimeFieldName(string dbPropertyName)
    {
        if (string.IsNullOrWhiteSpace(dbPropertyName))
        {
            return "_linkedRuntime";
        }

        string fieldStem = char.ToLowerInvariant(dbPropertyName[0]) + dbPropertyName.Substring(1);
        return "_" + fieldStem + "Runtime";
    }

    private static string BuildLinkFieldName(string targetStructName)
    {
        return "_link" + targetStructName + "InstanceId";
    }

    private static string ResolveRuntimeVariableType(DocColumnKind variableKind)
    {
        if (variableKind == DocColumnKind.Number)
        {
            return "double";
        }

        if (variableKind == DocColumnKind.Checkbox)
        {
            return "bool";
        }

        return "string";
    }

    private static string BuildStateFieldName(ExportTableVariableModel variable)
    {
        return "_value" + variable.SlotName;
    }

    private static string BuildOverrideFieldName(ExportTableVariableModel variable)
    {
        return "_override" + variable.SlotName;
    }

    private static string BuildValueEqualsExpression(ExportTableVariableModel variable, string currentValueExpression, string newValueExpression)
    {
        if (variable.Kind == DocColumnKind.Number)
        {
            return "Math.Abs(" + currentValueExpression + " - " + newValueExpression + ") <= 0.0000001";
        }

        if (variable.Kind == DocColumnKind.Checkbox)
        {
            return currentValueExpression + " == " + newValueExpression;
        }

        return "string.Equals(" + currentValueExpression + ", " + newValueExpression + ", StringComparison.Ordinal)";
    }

    private static string RenderRuntimeDefaultLiteral(ExportTableVariableModel variable)
    {
        string expression = variable.Expression.Trim();
        if (variable.Kind == DocColumnKind.Number)
        {
            if (double.TryParse(expression, NumberStyles.Float, CultureInfo.InvariantCulture, out double number))
            {
                return number.ToString("R", CultureInfo.InvariantCulture) + "d";
            }

            return "0d";
        }

        if (variable.Kind == DocColumnKind.Checkbox)
        {
            if (string.Equals(expression, "true", StringComparison.OrdinalIgnoreCase))
            {
                return "true";
            }

            if (string.Equals(expression, "false", StringComparison.OrdinalIgnoreCase))
            {
                return "false";
            }

            return "false";
        }

        if (TryParseQuotedStringLiteral(expression, out string stringValue))
        {
            return QuoteStringLiteral(stringValue);
        }

        return "\"\"";
    }

    private static bool TryParseQuotedStringLiteral(string expression, out string stringValue)
    {
        stringValue = "";
        if (expression.Length < 2 ||
            expression[0] != '"' ||
            expression[^1] != '"')
        {
            return false;
        }

        var valueBuilder = new StringBuilder(expression.Length - 2);
        for (int textIndex = 1; textIndex < expression.Length - 1; textIndex++)
        {
            char current = expression[textIndex];
            if (current == '\\' && textIndex + 1 < expression.Length - 1)
            {
                textIndex++;
                char escaped = expression[textIndex];
                valueBuilder.Append(escaped switch
                {
                    '\\' => '\\',
                    '"' => '"',
                    'n' => '\n',
                    'r' => '\r',
                    't' => '\t',
                    _ => escaped,
                });
                continue;
            }

            valueBuilder.Append(current);
        }

        stringValue = valueBuilder.ToString();
        return true;
    }

    private static string QuoteStringLiteral(string value)
    {
        var builder = new StringBuilder(value.Length + 2);
        builder.Append('"');
        for (int charIndex = 0; charIndex < value.Length; charIndex++)
        {
            char current = value[charIndex];
            if (current == '\\')
            {
                builder.Append("\\\\");
            }
            else if (current == '"')
            {
                builder.Append("\\\"");
            }
            else if (current == '\n')
            {
                builder.Append("\\n");
            }
            else if (current == '\r')
            {
                builder.Append("\\r");
            }
            else if (current == '\t')
            {
                builder.Append("\\t");
            }
            else
            {
                builder.Append(current);
            }
        }
        builder.Append('"');
        return builder.ToString();
    }

    private static string RenderGameDatabase(
        string ns,
        List<ExportTableModel> exportTables,
        string binaryFileName)
    {
        var sb = new StringBuilder(8192);
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using DerpDoc.Runtime;");
        sb.AppendLine();
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("public readonly struct DerpDocTableVariantInfo");
        sb.AppendLine("{");
        sb.AppendLine("    public DerpDocTableVariantInfo(int id, string name, string tableName)");
        sb.AppendLine("    {");
        sb.AppendLine("        Id = id;");
        sb.AppendLine("        Name = name;");
        sb.AppendLine("        TableName = tableName;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public int Id { get; }");
        sb.AppendLine("    public string Name { get; }");
        sb.AppendLine("    public string TableName { get; }");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("public sealed class GameDatabase : IDisposable");
        sb.AppendLine("{");
        sb.Append("    private const string BinaryFileName = \"").Append(binaryFileName).AppendLine("\";");
        sb.AppendLine("    private readonly DatabaseReloader _reloader;");
        sb.AppendLine("    private BinaryLoader? _activeLoader;");
        sb.AppendLine();

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            string localName = char.ToLowerInvariant(exportTable.DbPropertyName[0]) + exportTable.DbPropertyName.Substring(1);

            sb.Append("    private static readonly DerpDocTableVariantInfo[] s_").Append(localName).AppendLine("Variants = new DerpDocTableVariantInfo[]");
            sb.AppendLine("    {");
            sb.Append("        new DerpDocTableVariantInfo(0, \"Base\", ").Append(QuoteStringLiteral(exportTable.BinaryTableName)).AppendLine("),");
            for (int variantIndex = 0; variantIndex < exportTable.Table.Variants.Count; variantIndex++)
            {
                DocTableVariant variant = exportTable.Table.Variants[variantIndex];
                if (variant.Id == 0)
                {
                    continue;
                }

                sb.Append("        new DerpDocTableVariantInfo(")
                    .Append(variant.Id.ToString(CultureInfo.InvariantCulture))
                    .Append(", ")
                    .Append(QuoteStringLiteral(variant.Name))
                    .Append(", ")
                    .Append(QuoteStringLiteral(exportTable.BinaryTableName + "@v" + variant.Id.ToString(CultureInfo.InvariantCulture)))
                    .AppendLine("),");
            }
            sb.AppendLine("    };");
            sb.AppendLine();

            sb.Append("    public static ReadOnlySpan<DerpDocTableVariantInfo> ").Append(exportTable.DbPropertyName).AppendLine("Variants => s_" + localName + "Variants;");
            sb.AppendLine();
        }

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            sb.Append("    public ").Append(exportTable.StructName).Append("Table ").Append(exportTable.DbPropertyName).AppendLine(" { get; private set; }");
            sb.Append("    public ").Append(exportTable.StructName).Append("Runtime ").Append(exportTable.DbPropertyName).AppendLine("Runtime { get; private set; }");
        }

        sb.AppendLine();
        sb.AppendLine("    public event Action? Reloaded;");
        sb.AppendLine("    public bool HasData => _reloader.HasData;");
        sb.AppendLine("    public bool IsLiveConnected => _reloader.IsLiveConnected;");
        sb.AppendLine("    public string StatusText => _reloader.StatusText;");
        sb.AppendLine("    public string SourceText => _reloader.SourceText;");
        sb.AppendLine("    public string LastErrorText => _reloader.LastErrorText;");
        sb.AppendLine();

        sb.AppendLine("    public GameDatabase()");
        sb.AppendLine("    {");
        sb.AppendLine("        var paths = GameRootDiscovery.Discover(BinaryFileName);");
        sb.AppendLine("        _reloader = new DatabaseReloader(paths.LiveBinaryPath, paths.BakedBinaryPath);");
        sb.AppendLine("        _reloader.SnapshotChanged += OnSnapshotChanged;");
        sb.AppendLine("        _reloader.LoadInitial();");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public void Update() => _reloader.Update();");
        sb.AppendLine();
        sb.AppendLine("    public void ReloadNow() => _reloader.LoadInitial();");
        sb.AppendLine();

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            sb.Append("    public bool TryGet").Append(exportTable.DbPropertyName).AppendLine("Variant(int variantId, out " + exportTable.StructName + "Table table)");
            sb.AppendLine("    {");
            sb.AppendLine("        table = default;");
            sb.AppendLine("        if (variantId == 0)");
            sb.AppendLine("        {");
            sb.Append("            table = ").Append(exportTable.DbPropertyName).AppendLine(";");
            sb.AppendLine("            return true;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        if (_activeLoader == null)");
            sb.AppendLine("        {");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.Append("        if (!TryResolveVariantTableName(")
                .Append(exportTable.DbPropertyName)
                .Append("Variants, variantId, out string tableName))")
                .AppendLine();
            sb.AppendLine("        {");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.Append("        table = Create").Append(exportTable.DbPropertyName).AppendLine("Table(_activeLoader, tableName);");
            sb.AppendLine("        return true;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    private void OnSnapshotChanged(BinaryLoader loader)");
        sb.AppendLine("    {");
        sb.AppendLine("        _activeLoader = loader;");
        sb.AppendLine("        ApplySnapshot(loader);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private void ApplySnapshot(BinaryLoader loader)");
        sb.AppendLine("    {");

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            string localTableName = char.ToLowerInvariant(exportTable.DbPropertyName[0]) + exportTable.DbPropertyName.Substring(1) + "Table";
            sb.Append("        var ").Append(localTableName).Append(" = Create").Append(exportTable.DbPropertyName)
                .AppendLine("Table(loader, " + QuoteStringLiteral(exportTable.BinaryTableName) + ");");
        }

        sb.AppendLine();
        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            if (exportTable.SubtableChildren.Count <= 0)
            {
                continue;
            }

            string localTableName = char.ToLowerInvariant(exportTable.DbPropertyName[0]) + exportTable.DbPropertyName.Substring(1) + "Table";
            sb.Append("        ").Append(localTableName).Append(".ConnectSubtables(");
            for (int linkIndex = 0; linkIndex < exportTable.SubtableChildren.Count; linkIndex++)
            {
                ExportSubtableLinkModel link = exportTable.SubtableChildren[linkIndex];
                if (linkIndex > 0)
                {
                    sb.Append(", ");
                }

                string childLocalTableName = char.ToLowerInvariant(link.ChildTable.DbPropertyName[0]) + link.ChildTable.DbPropertyName.Substring(1) + "Table";
                sb.Append(childLocalTableName);
            }
            sb.AppendLine(");");
        }

        sb.AppendLine();
        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            string localTableName = char.ToLowerInvariant(exportTable.DbPropertyName[0]) + exportTable.DbPropertyName.Substring(1) + "Table";
            sb.Append("        ").Append(exportTable.DbPropertyName).Append(" = ").Append(localTableName).AppendLine(";");
            sb.Append("        ").Append(exportTable.DbPropertyName).Append("Runtime = new ").Append(exportTable.StructName).Append("Runtime(")
                .Append(exportTable.DbPropertyName).AppendLine(");");
        }

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            sb.Append("        ").Append(exportTable.DbPropertyName).Append("Runtime.ConnectRuntimes(");
            bool wroteArgument = false;
            for (int linkedIndex = 0; linkedIndex < exportTables.Count; linkedIndex++)
            {
                if (linkedIndex == tableIndex)
                {
                    continue;
                }

                if (wroteArgument)
                {
                    sb.Append(", ");
                }

                sb.Append(exportTables[linkedIndex].DbPropertyName).Append("Runtime");
                wroteArgument = true;
            }
            sb.AppendLine(");");
        }

        sb.AppendLine("        Reloaded?.Invoke();");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    private static bool TryResolveVariantTableName(ReadOnlySpan<DerpDocTableVariantInfo> variants, int variantId, out string tableName)");
        sb.AppendLine("    {");
        sb.AppendLine("        for (int variantIndex = 0; variantIndex < variants.Length; variantIndex++)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (variants[variantIndex].Id == variantId)");
        sb.AppendLine("            {");
        sb.AppendLine("                tableName = variants[variantIndex].TableName;");
        sb.AppendLine("                return true;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        tableName = \"\";");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        for (int tableIndex = 0; tableIndex < exportTables.Count; tableIndex++)
        {
            ExportTableModel exportTable = exportTables[tableIndex];
            sb.Append("    private static ").Append(exportTable.StructName).Append("Table Create").Append(exportTable.DbPropertyName).AppendLine("Table(BinaryLoader loader, string tableName)");
            sb.AppendLine("    {");
            sb.Append("        var acc = loader.GetTableAccessor<").Append(exportTable.StructName).Append(">(tableName);").AppendLine();
            if (exportTable.PrimaryKey != null)
            {
                sb.AppendLine("        var pk = loader.GetTableAccessor<DerpDocKeyRowIndexPair>(tableName + \"__pk_sorted\");");
            }

            for (int secondaryIndex = 0; secondaryIndex < exportTable.SecondaryKeys.Count; secondaryIndex++)
            {
                ExportSecondaryKeyModel secondaryKey = exportTable.SecondaryKeys[secondaryIndex];
                string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(secondaryKey.Column.Name), "Key");
                string indexSuffix = secondaryKey.BinaryIndexName.Substring(exportTable.BinaryTableName.Length);
                sb.Append("        var ").Append(keyName).Append("Idx = loader.GetTableAccessor<");
                sb.Append(secondaryKey.Unique ? "int" : "DerpDocKeyRowIndexPair");
                sb.Append(">(tableName + ").Append(QuoteStringLiteral(indexSuffix)).AppendLine(");");
            }
            if (exportTable.SubtableParent != null)
            {
                sb.AppendLine("        var subParentRanges = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + \"__sub_parent_ranges\");");
                sb.AppendLine("        var subParentRows = loader.GetTableAccessor<int>(tableName + \"__sub_parent_rows\");");
            }
            if (exportTable.RowReferences.Count > 0)
            {
                ExportRowReferenceModel rowReference = exportTable.RowReferences[0];
                string rowRefStem = CSharpIdentifier.Sanitize(rowReference.PropertyName, "RowRef");
                sb.Append("        var rowRef").Append(rowRefStem).Append("RowTargets = loader.GetTableAccessor<DerpDocTagPkPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.RowTargetsSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentKindRanges = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentKindRangesSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentKindRows = loader.GetTableAccessor<int>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentKindRowsSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentKindTargetMeta = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentKindTargetMetaSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentKindTargetRanges = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentKindTargetRangesSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentKindTargetRows = loader.GetTableAccessor<int>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentKindTargetRowsSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentTargetMeta = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentTargetMetaSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentTargetRanges = loader.GetTableAccessor<DerpDocRangeStartCountPair>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentTargetRangesSuffix)).AppendLine(");");
                sb.Append("        var rowRef").Append(rowRefStem).Append("ParentTargetRows = loader.GetTableAccessor<int>(tableName + ")
                    .Append(QuoteStringLiteral(rowReference.ParentTargetRowsSuffix)).AppendLine(");");
            }

            sb.Append("        return new ").Append(exportTable.StructName).Append("Table(acc");
            if (exportTable.PrimaryKey != null)
            {
                sb.Append(", pk");
            }
            for (int secondaryIndex = 0; secondaryIndex < exportTable.SecondaryKeys.Count; secondaryIndex++)
            {
                ExportSecondaryKeyModel secondaryKey = exportTable.SecondaryKeys[secondaryIndex];
                string keyName = CSharpIdentifier.Sanitize(CSharpIdentifier.ToPascalCase(secondaryKey.Column.Name), "Key");
                sb.Append(", ").Append(keyName).Append("Idx");
            }
            if (exportTable.SubtableParent != null)
            {
                sb.Append(", subParentRanges, subParentRows");
            }
            if (exportTable.RowReferences.Count > 0)
            {
                ExportRowReferenceModel rowReference = exportTable.RowReferences[0];
                string rowRefStem = CSharpIdentifier.Sanitize(rowReference.PropertyName, "RowRef");
                sb.Append(", rowRef").Append(rowRefStem).Append("RowTargets");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentKindRanges");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentKindRows");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentKindTargetMeta");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentKindTargetRanges");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentKindTargetRows");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentTargetMeta");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentTargetRanges");
                sb.Append(", rowRef").Append(rowRefStem).Append("ParentTargetRows");
            }
            sb.AppendLine(");");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("    public void Dispose()");
        sb.AppendLine("    {");
        sb.AppendLine("        _reloader.SnapshotChanged -= OnSnapshotChanged;");
        sb.AppendLine("        _reloader.Dispose();");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

}
