#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace Profiling.Generator
{
    [Generator]
    public sealed class ProfileScopeGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all [ProfileScope] attributes on classes and methods
            var scopeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "Profiling.ProfileScopeAttribute",
                predicate: static (node, _) => node is ClassDeclarationSyntax or MethodDeclarationSyntax,
                transform: static (ctx, _) => ExtractScopeName(ctx))
                .Where(static name => name is not null)
                .Select(static (name, _) => name!);

            // Collect all scope names and generate output
            var collected = scopeDeclarations.Collect();

            context.RegisterSourceOutput(collected, static (spc, scopeNames) =>
            {
                // Sort and deduplicate (handle empty case - still generate empty ProfileScopes)
                var uniqueNames = scopeNames.IsDefaultOrEmpty
                    ? new List<string>()
                    : scopeNames.Distinct().OrderBy(n => n).ToList();

                // Generate ProfileScopes class
                var scopesSource = GenerateProfileScopes(uniqueNames);
                spc.AddSource("ProfileScopes.g.cs", SourceText.From(scopesSource, Encoding.UTF8));

                // Generate ProfileScope ref struct
                var structSource = GenerateProfileScopeStruct();
                spc.AddSource("ProfileScope.g.cs", SourceText.From(structSource, Encoding.UTF8));
            });
        }

        private static string? ExtractScopeName(GeneratorAttributeSyntaxContext ctx)
        {
            var symbol = ctx.TargetSymbol;

            foreach (var attr in symbol.GetAttributes())
            {
                if (attr.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Profiling.ProfileScopeAttribute")
                {
                    // Get the name from the constructor argument
                    if (attr.ConstructorArguments.Length > 0 && attr.ConstructorArguments[0].Value is string name)
                    {
                        return name;
                    }
                }
            }

            return null;
        }

        private static string GenerateProfileScopes(List<string> scopeNames)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("namespace Profiling");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Generated constants for profiling scope IDs.");
            sb.AppendLine("    /// Use with ProfileScope.Begin(scopeId) for zero-allocation timing.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class ProfileScopes");
            sb.AppendLine("    {");

            // Generate scope ID constants
            for (int i = 0; i < scopeNames.Count; i++)
            {
                sb.AppendLine($"        public const int {scopeNames[i]} = {i};");
            }

            sb.AppendLine();
            sb.AppendLine($"        /// <summary>Total number of registered profile scopes.</summary>");
            sb.AppendLine($"        public const int Count = {scopeNames.Count};");
            sb.AppendLine();

            // Generate names array
            sb.AppendLine("        /// <summary>Scope names indexed by scope ID.</summary>");
            sb.Append("        public static readonly string[] Names = { ");
            sb.Append(string.Join(", ", scopeNames.Select(n => $"\"{n}\"")));
            sb.AppendLine(" };");

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateProfileScopeStruct()
        {
            return @"// <auto-generated/>
#nullable enable
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace Profiling
{
    /// <summary>
    /// Zero-allocation timing scope. Use with 'using var _ = ProfileScope.Begin(scopeId);'
    /// </summary>
    /// <remarks>
    /// This is a ref struct to ensure stack allocation and prevent boxing.
    /// The Dispose() method records timing to ProfilingService.Instance.
    /// </remarks>
    public ref struct ProfileScope
    {
        private readonly int _scopeId;
        private readonly long _startTicks;
#if FLAME_PROFILER
        private readonly int _flameNodeIndex;
#endif

        /// <summary>
        /// Begins a new profiling scope for the given scope ID.
        /// </summary>
        /// <param name=""scopeId"">The scope ID from ProfileScopes constants.</param>
        /// <returns>A ProfileScope that records timing when disposed.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ProfileScope Begin(int scopeId)
        {
#if FLAME_PROFILER
            int flameNodeIndex = -1;
            var flameService = global::FlameProfiler.FlameProfilerService.Instance;
            if (flameService != null && flameService.Enabled)
            {
                flameNodeIndex = flameService.BeginScope(scopeId);
            }

            return new ProfileScope(scopeId, Stopwatch.GetTimestamp(), flameNodeIndex);
#else
            return new ProfileScope(scopeId, Stopwatch.GetTimestamp());
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ProfileScope(int scopeId, long startTicks
#if FLAME_PROFILER
            , int flameNodeIndex
#endif
            )
        {
            _scopeId = scopeId;
            _startTicks = startTicks;
#if FLAME_PROFILER
            _flameNodeIndex = flameNodeIndex;
#endif
        }

        /// <summary>
        /// Records the elapsed time to the ProfilingService.
        /// Called automatically at end of 'using' block.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Dispose()
        {
            var service = ProfilingService.Instance;
            if (service != null && service.Enabled)
            {
                service.RecordTiming(_scopeId, Stopwatch.GetTimestamp() - _startTicks);
            }

#if FLAME_PROFILER
            var flameService = global::FlameProfiler.FlameProfilerService.Instance;
            if (flameService != null && flameService.Enabled)
            {
                flameService.EndScope(_flameNodeIndex);
            }
#endif
        }
    }
}
";
        }
    }
}
