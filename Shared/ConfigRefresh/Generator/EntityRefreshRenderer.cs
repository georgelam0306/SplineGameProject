#nullable enable
using System.Linq;
using System.Text;

namespace ConfigRefresh.Generator
{
    internal static class EntityRefreshRenderer
    {
        public static string Render(ConfigSourceModel model)
        {
            var ns = model.Type.ContainingNamespace?.ToDisplayString() ?? "global";
            var typeName = model.Type.Name;
            var tableName = typeName + "Table";
            var tablePropertyName = model.TableType.Name; // e.g., ZombieTypeData
            var typeIdField = model.TypeIdFieldName ?? "TypeId";
            bool hasMaxHealth = model.CachedFields.Any(f => f.FieldName == "MaxHealth");
            // Get GameDocDb namespace from the data type's namespace
            var gameDocDbNs = model.TableType.ContainingNamespace?.ToDisplayString() ?? "GameData.Schemas";
            var gameDocDbType = $"{gameDocDbNs}.GameDocDb";

            var sb = new StringBuilder(4096);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");

            // Generate static extension methods class
            sb.AppendLine($"    public static class {typeName}ConfigRefresh");
            sb.AppendLine("    {");

            // Generate InitializeStats (SimHandle overload) - for spawners
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Initializes cached stat values for a single entity from its type data.");
            sb.AppendLine("        /// Call this from spawners after setting TypeId.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine($"        public static void InitializeStats(this {tableName} table, global::SimTable.SimHandle handle, {gameDocDbType} db)");
            sb.AppendLine("        {");
            sb.AppendLine("            var row = table.GetRow(handle);");
            sb.AppendLine($"            ref readonly var typeData = ref db.{tablePropertyName}.FindById((int)row.{typeIdField});");
            sb.AppendLine();

            // Initialize each stat field
            foreach (var field in model.CachedFields)
            {
                sb.AppendLine($"            row.{field.FieldName} = typeData.{field.SourcePropertyName};");
            }

            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate InitializeStats (int slot overload) - for RefreshStats iteration
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Initializes cached stat values for a single entity by slot index.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine($"        public static void InitializeStats(this {tableName} table, int slot, {gameDocDbType} db)");
            sb.AppendLine("        {");
            sb.AppendLine("            var row = table.GetRowBySlot(slot);");
            sb.AppendLine($"            ref readonly var typeData = ref db.{tablePropertyName}.FindById((int)row.{typeIdField});");
            sb.AppendLine();

            // Initialize each stat field
            foreach (var field in model.CachedFields)
            {
                sb.AppendLine($"            row.{field.FieldName} = typeData.{field.SourcePropertyName};");
            }

            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate RefreshStats - only in HOT_RELOAD builds, calls InitializeStats
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Refreshes cached stat values for all entities in the table.");
            sb.AppendLine("        /// Call this from GameDataRefreshSystem when hot-reload occurs.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("#if HOT_RELOAD");
            sb.AppendLine($"        public static void RefreshStats(this {tableName} table, {gameDocDbType} db)");
            sb.AppendLine("        {");
            sb.AppendLine("            int count = table.Count;");
            sb.AppendLine("            for (int slot = 0; slot < count; slot++)");
            sb.AppendLine("            {");
            sb.AppendLine("                if (!table.TryGetRow(slot, out var row)) continue;");
            sb.AppendLine();
            sb.AppendLine($"                ref readonly var typeData = ref db.{tablePropertyName}.FindById((int)row.{typeIdField});");
            sb.AppendLine();

            // Refresh each stat field
            foreach (var field in model.CachedFields)
            {
                sb.AppendLine($"                row.{field.FieldName} = typeData.{field.SourcePropertyName};");
            }

            // Check if MaxHealth exists - if so, cap Health to MaxHealth (hot-reload specific)
            if (hasMaxHealth)
            {
                sb.AppendLine();
                sb.AppendLine("                // Cap current Health to new MaxHealth");
                sb.AppendLine("                if (row.Health > row.MaxHealth)");
                sb.AppendLine("                    row.Health = row.MaxHealth;");
            }

            sb.AppendLine("            }");
            sb.AppendLine("            // Note: RecomputeAll() is called by SimWorld.BeginFrame() after RefreshStats");
            sb.AppendLine("        }");
            sb.AppendLine("#else");
            sb.AppendLine("        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        public static void RefreshStats(this {tableName} table, {gameDocDbType} db) {{ }}");
            sb.AppendLine("#endif");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
}
