#nullable enable
using System.Collections.Immutable;
using System.Text;

namespace Grid.Generator;

internal static class WorldGridRenderer
{
    public static string Render(WorldGridModel world, ImmutableArray<DataGridModel?> dataGrids)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Core;");
        sb.AppendLine();
        sb.AppendLine($"namespace {world.Namespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// World tile coordinate. Each tile is {world.TileSize}x{world.TileSize} pixels.");
        sb.AppendLine($"/// Map is {world.WidthTiles}x{world.HeightTiles} tiles ({world.MapWidthPixels}x{world.MapHeightPixels} pixels).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public readonly struct WorldTile : IEquatable<WorldTile>");
        sb.AppendLine("{");

        // Constants
        sb.AppendLine($"    public const int TileSize = {world.TileSize};");
        sb.AppendLine($"    public const int WidthTiles = {world.WidthTiles};");
        sb.AppendLine($"    public const int HeightTiles = {world.HeightTiles};");
        sb.AppendLine($"    public const int MapWidthPixels = {world.MapWidthPixels};");
        sb.AppendLine($"    public const int MapHeightPixels = {world.MapHeightPixels};");
        sb.AppendLine();

        // Pre-computed Fixed64 constants
        sb.AppendLine("    public static readonly Fixed64 TileSizeFixed = Fixed64.FromInt(TileSize);");
        sb.AppendLine("    public static readonly Fixed64 HalfTileSizeFixed = Fixed64.FromInt(TileSize / 2);");
        sb.AppendLine();

        // Fields
        sb.AppendLine("    public readonly int X;");
        sb.AppendLine("    public readonly int Y;");
        sb.AppendLine();
        sb.AppendLine("    public static readonly WorldTile Zero = new(0, 0);");
        sb.AppendLine();

        // Constructor
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public WorldTile(int x, int y)");
        sb.AppendLine("    {");
        sb.AppendLine("        X = x;");
        sb.AppendLine("        Y = y;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Factory Methods
        sb.AppendLine("    // === Factory Methods ===");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Convert pixel position to tile coordinate (floors).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile FromPixel(Fixed64Vec2 pixelPos)");
        sb.AppendLine("    {");
        sb.AppendLine("        int tileX = (pixelPos.X / TileSizeFixed).ToInt();");
        sb.AppendLine("        int tileY = (pixelPos.Y / TileSizeFixed).ToInt();");
        sb.AppendLine("        return new WorldTile(tileX, tileY);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Convert pixel position to tile coordinate (floors).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile FromPixel(int pixelX, int pixelY)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new WorldTile(pixelX / TileSize, pixelY / TileSize);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Convert from IntVec2 pixel position.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile FromPixel(IntVec2 pixelPos)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new WorldTile(pixelPos.X / TileSize, pixelPos.Y / TileSize);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Conversion Methods
        sb.AppendLine("    // === Conversion Methods ===");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Get world position of tile center.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public Fixed64Vec2 ToPixelCenter()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new Fixed64Vec2(");
        sb.AppendLine("            Fixed64.FromInt(X * TileSize) + HalfTileSizeFixed,");
        sb.AppendLine("            Fixed64.FromInt(Y * TileSize) + HalfTileSizeFixed");
        sb.AppendLine("        );");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Get world position of tile top-left corner.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public Fixed64Vec2 ToPixelTopLeft()");
        sb.AppendLine("    {");
        sb.AppendLine("        return Fixed64Vec2.FromInt(X * TileSize, Y * TileSize);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Get pixel center as integers.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public (int x, int y) ToPixelCenterInt()");
        sb.AppendLine("    {");
        sb.AppendLine("        return (X * TileSize + TileSize / 2, Y * TileSize + TileSize / 2);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Convert to IntVec2.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public IntVec2 ToIntVec2()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new IntVec2(X, Y);");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Convert to 1D array index (row-major).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public int ToIndex()");
        sb.AppendLine("    {");
        sb.AppendLine("        return Y * WidthTiles + X;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Create from 1D array index (row-major).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile FromIndex(int index)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new WorldTile(index % WidthTiles, index / WidthTiles);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Bounds Checking
        sb.AppendLine("    // === Bounds Checking ===");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Check if tile is within map bounds.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public bool IsInBounds()");
        sb.AppendLine("    {");
        sb.AppendLine("        return X >= 0 && X < WidthTiles && Y >= 0 && Y < HeightTiles;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Clamp to map bounds.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public WorldTile Clamped()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new WorldTile(");
        sb.AppendLine("            Math.Clamp(X, 0, WidthTiles - 1),");
        sb.AppendLine("            Math.Clamp(Y, 0, HeightTiles - 1)");
        sb.AppendLine("        );");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Operators
        sb.AppendLine("    // === Operators ===");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile operator +(WorldTile a, WorldTile b)");
        sb.AppendLine("        => new(a.X + b.X, a.Y + b.Y);");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static WorldTile operator -(WorldTile a, WorldTile b)");
        sb.AppendLine("        => new(a.X - b.X, a.Y - b.Y);");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static bool operator ==(WorldTile a, WorldTile b)");
        sb.AppendLine("        => a.X == b.X && a.Y == b.Y;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static bool operator !=(WorldTile a, WorldTile b)");
        sb.AppendLine("        => a.X != b.X || a.Y != b.Y;");
        sb.AppendLine();

        // IEquatable
        sb.AppendLine("    // === IEquatable ===");
        sb.AppendLine();
        sb.AppendLine("    public bool Equals(WorldTile other) => X == other.X && Y == other.Y;");
        sb.AppendLine("    public override bool Equals(object? obj) => obj is WorldTile other && Equals(other);");
        sb.AppendLine("    public override int GetHashCode() => HashCode.Combine(X, Y);");
        sb.AppendLine("    public override string ToString() => $\"Tile({X}, {Y})\";");
        sb.AppendLine();

        // Cross-grid conversions for each DataGrid type
        if (!dataGrids.IsDefaultOrEmpty)
        {
            sb.AppendLine("    // === Cross-Grid Conversions ===");
            sb.AppendLine();
            foreach (var dataGrid in dataGrids)
            {
                if (dataGrid == null) continue;
                int cellSizeInTiles = dataGrid.CellSizePixels / world.TileSize;
                sb.AppendLine($"    /// <summary>Convert to {dataGrid.TypeName} ({cellSizeInTiles} tiles per cell).</summary>");
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"    public {dataGrid.TypeName} To{dataGrid.TypeName}() => {dataGrid.TypeName}.FromTile(this);");
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
}
