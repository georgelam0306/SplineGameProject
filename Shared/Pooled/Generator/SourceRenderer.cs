// SPDX-License-Identifier: MIT
#nullable enable
using Microsoft.CodeAnalysis;
using System;
using System.Globalization;
using System.Text;

namespace Pooled.Generator
{
	internal static class SourceRenderer
	{
		public static string Render(SchemaModel model)
		{
			var ns = model.Type.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::";
			var typeName = model.Type.Name;
			var schemaFqn = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var nestedViewType = typeName + ".ViewProxy";
			var sb = new StringBuilder(32_768);
			sb.AppendLine("// <auto-generated/>\n#nullable enable");
			if (!string.IsNullOrEmpty(ns) && ns != "global::")
			{
				sb.Append("namespace ").Append(ns.Replace("global::", string.Empty)).AppendLine()
				  .AppendLine("{");
			}

			// Handle
			sb.AppendLine("\tpublic readonly struct " + typeName + "Handle : System.IEquatable<" + typeName + "Handle>");
			sb.AppendLine("\t{");
			sb.AppendLine("\t\tpublic readonly uint Index; public readonly uint Generation;\n\t\tpublic " + typeName + "Handle(uint index, uint generation) { Index = index; Generation = generation; }");
			sb.AppendLine("\t\tpublic bool IsNull => Generation == 0;\n\t\tpublic bool Equals(" + typeName + "Handle other) => Index == other.Index && Generation == other.Generation;\n\t\tpublic override bool Equals(object? obj) => obj is " + typeName + "Handle o && Equals(o);\n\t\tpublic override int GetHashCode() => ((int)Index * 397) ^ (int)Generation;\n\t\tpublic static bool operator==(" + typeName + "Handle a, " + typeName + "Handle b) => a.Equals(b);\n\t\tpublic static bool operator!=(" + typeName + "Handle a, " + typeName + "Handle b) => !a.Equals(b);\n\t}");

			// Id (optional)
			if (model.GenerateStableId)
			{
				var idBlock =
					"\tpublic readonly struct " + typeName + "Id : System.IEquatable<" + typeName + "Id>\n" +
					"\t{\n" +
					"\t\tpublic readonly ulong Value; public " + typeName + "Id(ulong value) { Value = value; }\n" +
					"\t\tpublic bool Equals(" + typeName + "Id other) => Value == other.Value;\n" +
					"\t\tpublic override bool Equals(object? obj) => obj is " + typeName + "Id o && Equals(o);\n" +
					"\t\tpublic override int GetHashCode() => Value.GetHashCode();\n" +
					"\t\tpublic static implicit operator ulong(" + typeName + "Id id) => id.Value;\n" +
					"\t\tpublic override string ToString() => Value.ToString(System.Globalization.CultureInfo.InvariantCulture);\n" +
					"\t}\n";
				sb.AppendLine(idBlock);
				// Ref wrapper for stable id
				sb.AppendLine("\tpublic readonly struct " + typeName + "Ref : System.IEquatable<" + typeName + "Ref>");
				sb.AppendLine("\t{");
				sb.AppendLine("\t\tpublic readonly " + typeName + "Id Id;");
				sb.AppendLine("\t\tpublic " + typeName + "Ref(" + typeName + "Id id) { Id = id; }");
				sb.AppendLine("\t\tpublic bool IsSet => !Id.Equals(default);");
				sb.AppendLine("\t\tpublic bool Equals(" + typeName + "Ref other) => Id.Equals(other.Id);");
				sb.AppendLine("\t\tpublic override bool Equals(object? o) => o is " + typeName + "Ref r && Equals(r);");
				sb.AppendLine("\t\tpublic override int GetHashCode() => Id.GetHashCode();");
				sb.AppendLine("\t\tpublic override string ToString() => \"ref:\" + Id.ToString();");
				sb.AppendLine("\t}\n");
			}

			// Pool signature
			sb.AppendLine("\tpublic sealed class " + typeName + "Pool");
			sb.AppendLine("\t{");
			sb.AppendLine("\t\tprivate uint[] _gen; private bool[] _alive; private int[] _free; private int _freeTop; private int _cap; private int _count;\n\t\tprivate uint _epoch; private uint[]? _slotEpoch; private int _borrows; private readonly object _sync = new object();");
			sb.AppendLine("\t\tprivate int[] _active; private int[] _activeIndex; private int _activeCount;\n");
			// Residency/versioning fields
			sb.AppendLine("\t\tprivate uint[] _version;");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\tprivate int[] _refCount; private byte[] _state; private long[] _lastUsed;\n\t\tpublic enum SlotState : byte { Unloaded, Loading, Ready, EvictPending, Failed }");
			}
			if (model.GenerateStableId)
			{
				sb.AppendLine("\t\tprivate readonly System.Collections.Generic.Dictionary<" + typeName + "Id, " + typeName + "Handle> _idToHandle = new System.Collections.Generic.Dictionary<" + typeName + "Id, " + typeName + "Handle>();");
				sb.AppendLine("\t\tprivate " + typeName + "Id[] _handleToId = new " + typeName + "Id[16];");
			}

			// Columns storage
			if (model.SoA)
			{
				bool hasSidecar = false;
				for (int i = 0; i < model.Columns.Count; i++)
				{
					if (model.Columns[i].Storage != 0)
					{
						hasSidecar = true;
						break;
					}
				}

				if (hasSidecar)
				{
					sb.AppendLine("\t\tprivate int _sidecarCap;");
				}

				foreach (var c in model.Columns)
				{
					var colType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					if (c.Storage == 0)
					{
						sb.AppendLine("\t\tprivate " + colType + "[] _" + c.Name + ";");
					}
					else
					{
						sb.AppendLine("\t\tprivate " + colType + "[] _sc_" + c.Name + ";");
					}
				}
			}
			else
			{
				var fqType = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				sb.AppendLine("\t\tprivate " + fqType + "[] _items;\n");
			}

			// Ctor
			sb.AppendLine("\t\tpublic " + typeName + "Pool(int initialCapacity = " + model.InitialCapacity + ")");
			sb.AppendLine("\t\t{\n\t\t\tif (initialCapacity < 1) initialCapacity = 1; _cap = initialCapacity;\n\t\t\t_gen = new uint[_cap]; _alive = new bool[_cap]; _free = new int[_cap]; _freeTop = -1; _count = 0; _epoch = 1;\n\t\t\t_slotEpoch = " + (model.ResetPolicy == 1 ? "new uint[_cap]" : "null") + ";");
			// init version/residency arrays
			sb.AppendLine("\t\t\t_version = new uint[_cap];");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\t_refCount = new int[_cap]; _state = new byte[_cap]; _lastUsed = new long[_cap];");
			}
			if (model.SoA)
			{
				bool hasSidecar = false;
				for (int i = 0; i < model.Columns.Count; i++)
				{
					if (model.Columns[i].Storage != 0)
					{
						hasSidecar = true;
						break;
					}
				}

				if (hasSidecar)
				{
					sb.AppendLine("\t\t\t_sidecarCap = _cap;");
				}

				foreach (var c in model.Columns)
				{
					var colType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					var elementType = colType;
					var jaggedSuffix = string.Empty;
					while (elementType.EndsWith("[]", StringComparison.Ordinal))
					{
						elementType = elementType.Substring(0, elementType.Length - 2);
						jaggedSuffix += "[]";
					}
					if (c.Storage == 0)
					{
						sb.AppendLine("\t\t\t_" + c.Name + " = new " + elementType + "[_cap]" + jaggedSuffix + ";");
					}
					else
					{
						sb.AppendLine("\t\t\t_sc_" + c.Name + " = new " + elementType + "[_sidecarCap]" + jaggedSuffix + ";");
					}
				}
			}
			else
			{
				var fqType = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				sb.AppendLine("\t\t\t_items = new " + fqType + "[_cap];");
			}
			sb.AppendLine("\t\t\t_active = new int[_cap]; _activeIndex = new int[_cap]; _activeCount = 0;\n\t\t}\n");

			// API Allocate/Free/IsValid
			sb.AppendLine("\t\tpublic " + typeName + "Handle Allocate(in " + model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + " init = default)");
			sb.AppendLine("\t\t{\n\t\t\tint idx;\n" + (model.ThreadSafe ? "\t\t\tlock(_sync) { " : "") + "\n\t\t\tif (_freeTop >= 0) { idx = _free[_freeTop--]; } else { if (_count == _cap) Grow(); idx = _count++; }\n" + (model.ThreadSafe ? "\t\t\t}" : "") + "\n\t\t\tif (_gen[idx] == 0) _gen[idx] = 1; _alive[idx] = true;\n\t\t\tif (_slotEpoch != null) _slotEpoch[idx] = _epoch;\n\t\t\t_activeIndex[idx] = _activeCount; _active[_activeCount++] = idx;\n");
			// set version/state
			sb.AppendLine("\t\t\t_version[idx] = 1;");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\t_state[idx] = (byte)SlotState.Ready; _lastUsed[idx] = _epoch;\n");
			}
			if (model.SoA)
			{
				foreach (var c in model.Columns)
				{
					if (c.Storage == 0)
					{
						sb.AppendLine("\t\t\t_" + c.Name + "[idx] = init." + c.Name + ";");
					}
				}
			}
			else
			{
				sb.AppendLine("\t\t\t_items[idx] = init;");
			}
			sb.AppendLine("\t\t\treturn new " + typeName + "Handle((uint)idx, _gen[idx]);\n\t\t}\n");

			if (model.SoA)
			{
				bool hasSidecar = false;
				for (int i = 0; i < model.Columns.Count; i++)
				{
					if (model.Columns[i].Storage != 0)
					{
						hasSidecar = true;
						break;
					}
				}

				if (hasSidecar && model.GenerateStableId)
				{
					sb.AppendLine("\t\tinternal void InitSidecarFromInit(" + typeName + "Handle h, in " + schemaFqn + " init)");
					sb.AppendLine("\t\t{");
					sb.AppendLine("\t\t\tif (!TryGetId(h, out var id)) throw new System.InvalidOperationException(\"Sidecar columns require a mapped stable id. Use CreateWithId.\");");
					sb.AppendLine("\t\t\tif (id.Value > int.MaxValue) throw new System.InvalidOperationException(\"Stable id exceeds supported sidecar range.\");");
					sb.AppendLine("\t\t\tint idIndex = (int)id.Value;");
					sb.AppendLine("\t\t\tif (idIndex <= 0) throw new System.InvalidOperationException(\"Stable id must be non-zero for sidecar columns.\");");
					sb.AppendLine("\t\t\tEnsureSidecarCapacity(idIndex + 1);");
					for (int i = 0; i < model.Columns.Count; i++)
					{
						var c = model.Columns[i];
						if (c.Storage == 0)
						{
							continue;
						}
						sb.AppendLine("\t\t\t_sc_" + c.Name + "[idIndex] = init." + c.Name + ";");
					}
					sb.AppendLine("\t\t}");
					sb.AppendLine();
				}
			}

			string freeLine;
			if (model.RefCounting != 0)
			{
				freeLine = "\t\tpublic void Free(" + typeName + "Handle h) { if (!IsValid(h)) return; int idx = (int)h.Index; if (_refCount[idx] > 0) { _state[idx] = (byte)SlotState.EvictPending; return; } DestroyNow(idx, h); }";
			}
			else
			{
				freeLine = "\t\tpublic void Free(" + typeName + "Handle h) { if (!IsValid(h)) return; int idx = (int)h.Index; " + (model.ThreadSafe ? "lock(_sync){ if (!IsValid(h)) return; " : string.Empty) + (model.GenerateStableId ? "UnmapIdForHandle(idx, h); " : string.Empty) + "_alive[idx] = false; _gen[idx]++; _free[++_freeTop] = idx; int pos = _activeIndex[idx]; int last = _activeCount - 1; if (pos <= last) { int lastIdx = _active[last]; _active[pos] = lastIdx; _activeIndex[lastIdx] = pos; } _activeCount = last; _activeIndex[idx] = -1; " + (model.ThreadSafe ? "}" : string.Empty) + " }";
			}
			sb.AppendLine(freeLine);
			var isValidLine = "\t\tpublic bool IsValid(" + typeName + "Handle h) { int idx = (int)h.Index; if (h.Generation == 0 || idx < 0 || idx >= _cap) return false; if (!_alive[idx]) return false; if (_gen[idx] != h.Generation) return false; if (_slotEpoch != null && _slotEpoch[idx] != _epoch) return false; return true; }";
			sb.AppendLine(isValidLine);
			sb.AppendLine("\t\tpublic int Count => _count; public int Capacity => _cap;\n");
			if (model.ResetPolicy == 1)
			{
				sb.AppendLine("\t\tpublic void ResetFrame() { _epoch++; }\n");
			}

			// Borrow guard
			sb.AppendLine("\t\tinternal BorrowToken BorrowEnter() { _borrows++; return new BorrowToken(this); }");
			sb.AppendLine("\t\tprivate void BorrowExit() { _borrows--; }");
			sb.AppendLine("\t\tinternal readonly struct BorrowToken : System.IDisposable { private readonly " + typeName + "Pool _p; public BorrowToken(" + typeName + "Pool p) { _p = p; } public void Dispose() => _p.BorrowExit(); }\n");

			// Grow
			sb.AppendLine("\t\tprivate void Grow() { if (_borrows > 0) throw new System.InvalidOperationException(\"Pool cannot grow while borrowed\"); int newCap = _cap * 2; Array.Resize(ref _gen, newCap); Array.Resize(ref _alive, newCap); Array.Resize(ref _free, newCap); if (_slotEpoch != null) Array.Resize(ref _slotEpoch, newCap); Array.Resize(ref _version, newCap);");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\tArray.Resize(ref _refCount, newCap); Array.Resize(ref _state, newCap); Array.Resize(ref _lastUsed, newCap);");
			}
			if (model.SoA)
			{
				foreach (var c in model.Columns)
				{
					if (c.Storage == 0)
					{
						sb.AppendLine("\t\t\tArray.Resize(ref _" + c.Name + ", newCap);");
					}
				}
			}
			else
			{
				var fqType = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				sb.AppendLine("\t\t\tArray.Resize(ref _items, newCap);");
			}
			sb.AppendLine("\t\t\tArray.Resize(ref _active, newCap); Array.Resize(ref _activeIndex, newCap);\n\t\t\t_cap = newCap; }\n");

			if (model.SoA && model.GenerateStableId)
			{
				bool hasSidecar = false;
				for (int i = 0; i < model.Columns.Count; i++)
				{
					if (model.Columns[i].Storage != 0)
					{
						hasSidecar = true;
						break;
					}
				}

				if (hasSidecar)
				{
					sb.AppendLine("\t\tprivate void EnsureSidecarCapacity(int size)");
					sb.AppendLine("\t\t{");
					sb.AppendLine("\t\t\tif (_sidecarCap >= size)");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine("\t\t\t\treturn;");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine();
					sb.AppendLine("\t\t\tint newCap = _sidecarCap <= 0 ? 16 : _sidecarCap * 2;");
					sb.AppendLine("\t\t\tif (newCap < size)");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine("\t\t\t\tnewCap = size;");
					sb.AppendLine("\t\t\t}");
					for (int i = 0; i < model.Columns.Count; i++)
					{
						var c = model.Columns[i];
						if (c.Storage == 0)
						{
							continue;
						}
						sb.AppendLine("\t\t\tSystem.Array.Resize(ref _sc_" + c.Name + ", newCap);");
					}
					sb.AppendLine("\t\t\t_sidecarCap = newCap;");
					sb.AppendLine("\t\t}");
					sb.AppendLine();
				}
			}

			// Version helpers
			sb.AppendLine("\t\tinternal uint VersionGet(" + typeName + "Handle h) => _version[(int)h.Index];");
			sb.AppendLine("\t\tinternal ref uint VersionRef(" + typeName + "Handle h) => ref _version[(int)h.Index];\n");
			// Optional version bump event
			sb.AppendLine("\t\tpublic event System.Action<" + typeName + "Handle, uint>? OnVersionBumped;");
			// Transactional commit helper
			sb.AppendLine("\t\tpublic void Commit(" + typeName + "Handle h, System.Action<" + typeName + ".Edit> apply, bool bumpVersion = true, bool markReady = true)");
			sb.AppendLine("\t\t{");
			sb.AppendLine("\t\t\tif (!IsValid(h)) return;");
			sb.AppendLine("\t\t\tusing var e = new " + typeName + ".Edit(this, h);");
			sb.AppendLine("\t\t\tapply(e);");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\tif (markReady) _state[(int)h.Index] = (byte)SlotState.Ready;");
				sb.AppendLine("\t\t\t_lastUsed[(int)h.Index] = _epoch;");
			}
			sb.AppendLine("\t\t\tif (bumpVersion) { unchecked { _version[(int)h.Index]++; } OnVersionBumped?.Invoke(h, _version[(int)h.Index]); }");
			sb.AppendLine("\t\t}\n");

			// AoS AtomicSwap convenience
			if (!model.SoA)
			{
				var fqType = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				sb.AppendLine("\t\tpublic void AtomicSwap(" + typeName + "Handle h, in " + fqType + " value, bool bumpVersion = true)");
				sb.AppendLine("\t\t{");
				sb.AppendLine("\t\t\tif (!IsValid(h)) return;");
				sb.AppendLine("\t\t\tusing var e = new " + typeName + ".Edit(this, h);");
				sb.AppendLine("\t\t\t_items[(int)h.Index] = value;");
				sb.AppendLine("\t\t\tif (bumpVersion) { unchecked { _version[(int)h.Index]++; } OnVersionBumped?.Invoke(h, _version[(int)h.Index]); }");
				sb.AppendLine("\t\t}\n");
			}

			// Safer view acquisition
			sb.AppendLine("\t\tpublic bool TryGetView(" + typeName + "Handle h, out " + nestedViewType + " v) { if (!IsValid(h)) { v = default; return false; } v = new " + nestedViewType + "(this, h); return true; }\n");

			// Pinning APIs (CpuOnly only)
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\tpublic readonly struct Lease : System.IDisposable { private readonly " + typeName + "Pool _p; private readonly int _idx; private readonly uint _gen; internal Lease(" + typeName + "Pool p, int idx, uint gen) { _p=p; _idx=idx; _gen=gen; } public void Dispose() => _p.Release(_idx, _gen); public bool IsValid => _p != null; }\n");
				var inc = model.ThreadSafe ? "System.Threading.Interlocked.Increment(ref _refCount[idx]);" : "++_refCount[idx];";
				var dec = model.ThreadSafe ? "System.Threading.Interlocked.Decrement(ref _refCount[idx])" : "--_refCount[idx]";
				sb.AppendLine("\t\tpublic Lease PinCPU(" + typeName + "Handle h) { int idx = (int)h.Index; if (!IsValid(h)) return default; " + inc + " if (_gen[idx] != h.Generation || !_alive[idx]) { " + (model.ThreadSafe ? "System.Threading.Interlocked.Decrement(ref _refCount[idx]);" : "--_refCount[idx];") + " return default; } _lastUsed[idx] = _epoch; return new Lease(this, idx, h.Generation); }\n");
				sb.AppendLine("\t\tinternal void Release(int idx, uint gen) { if (_gen[idx] != gen) return; int rc = " + dec + "; if (rc == 0 && _state[idx] == (byte)SlotState.EvictPending) DestroyNow(idx, new " + typeName + "Handle((uint)idx, gen)); }\n");
			}

			// DestroyNow helper
			if (model.RefCounting != 0)
			{
				string destroyBody = "\t\tprivate void DestroyNow(int idx, " + typeName + "Handle h) { " + (model.GenerateStableId ? "UnmapIdForHandle(idx, h); " : string.Empty) + "_alive[idx] = false; unchecked { _gen[idx]++; } _state[idx] = (byte)SlotState.Unloaded; _version[idx] = 0; _refCount[idx] = 0; _free[++_freeTop] = idx; int pos = _activeIndex[idx]; int last = _activeCount - 1; if (pos <= last) { int lastIdx = _active[last]; _active[pos] = lastIdx; _activeIndex[lastIdx] = pos; } _activeCount = last; _activeIndex[idx] = -1; }";
				sb.AppendLine(destroyBody + "\n");
			}

			// Optional utilities
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\tinternal bool IsEvictable(int idx) => _alive[idx] && _state[idx] == (byte)SlotState.Ready && _refCount[idx] == 0;\n");
				sb.AppendLine("\t\tinternal void Touch(" + typeName + "Handle h) { if (IsValid(h)) _lastUsed[(int)h.Index] = _epoch; }\n");
				// Explicit state helpers
				sb.AppendLine("\t\tpublic " + typeName + "Pool.SlotState GetState(" + typeName + "Handle h) => (" + typeName + "Pool.SlotState)_state[(int)h.Index];");
				sb.AppendLine("\t\tinternal void MarkLoading(" + typeName + "Handle h) { if (!IsValid(h)) return; _state[(int)h.Index] = (byte)SlotState.Loading; _lastUsed[(int)h.Index] = _epoch; }");
				sb.AppendLine("\t\tinternal void MarkReady(" + typeName + "Handle h) { if (!IsValid(h)) return; _state[(int)h.Index] = (byte)SlotState.Ready; _lastUsed[(int)h.Index] = _epoch; }");
				sb.AppendLine("\t\tinternal void MarkEvictPending(" + typeName + "Handle h) { if (!IsValid(h)) return; _state[(int)h.Index] = (byte)SlotState.EvictPending; }");
				sb.AppendLine("\t\tinternal void MarkFailed(" + typeName + "Handle h) { if (!IsValid(h)) return; _state[(int)h.Index] = (byte)SlotState.Failed; }");
			}

			// Column accessors
			if (model.SoA)
			{
				foreach (var c in model.Columns)
				{
					var colType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

					if (c.Storage == 0 || !model.GenerateStableId)
					{
						var refAccessor =
							"\t\tpublic ref " + colType + " " + c.Name + "Ref(" + typeName + "Handle h)\n" +
							"\t\t{\n" +
							"#if DEBUG\n" +
							"\t\t\tif(!IsValid(h)) throw new System.InvalidOperationException(\"Invalid handle\");\n" +
							"#endif\n" +
							"\t\t\treturn ref _" + c.Name + "[(int)h.Index];\n" +
							"\t\t}";
						sb.AppendLine(refAccessor);
					}
					else
					{
						sb.AppendLine("\t\tpublic ref " + colType + " " + c.Name + "Ref(" + typeName + "Handle h)");
						sb.AppendLine("\t\t{");
						sb.AppendLine("#if DEBUG");
						sb.AppendLine("\t\t\tif(!IsValid(h)) throw new System.InvalidOperationException(\"Invalid handle\");");
						sb.AppendLine("#endif");
						sb.AppendLine("\t\t\tif (!TryGetId(h, out var id)) throw new System.InvalidOperationException(\"Sidecar columns require a mapped stable id. Use CreateWithId.\");");
						sb.AppendLine("\t\t\tif (id.Value > int.MaxValue) throw new System.InvalidOperationException(\"Stable id exceeds supported sidecar range.\");");
						sb.AppendLine("\t\t\tint idIndex = (int)id.Value;");
						sb.AppendLine("\t\t\tif (idIndex <= 0) throw new System.InvalidOperationException(\"Stable id must be non-zero for sidecar columns.\");");
						sb.AppendLine("\t\t\tEnsureSidecarCapacity(idIndex + 1);");
						sb.AppendLine("\t\t\treturn ref _sc_" + c.Name + "[idIndex];");
						sb.AppendLine("\t\t}");
					}

					if (c.ReadOnly)
					{
						sb.AppendLine("\t\tpublic " + colType + " " + c.Name + "Get(" + typeName + "Handle h) => " + c.Name + "Ref(h);");
					}
				}
			}
			else
			{
				var fqType = model.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				var getRef =
					"\t\tpublic ref " + fqType + " GetRef(" + typeName + "Handle h)\n" +
					"\t\t{\n" +
					"#if DEBUG\n" +
					"\t\t\tif(!IsValid(h)) throw new System.InvalidOperationException(\"Invalid handle\");\n" +
					"#endif\n" +
					"\t\t\treturn ref _items[(int)h.Index];\n" +
					"\t\t}";
				sb.AppendLine(getRef);
			}

			// Iteration helpers
			sb.AppendLine("\t\t[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
			sb.AppendLine("\t\tinternal bool TryNextLive(int start, out int liveIndex) { for (int pos = start; pos < _activeCount; pos++) { int idx = _active[pos]; if (_slotEpoch == null || _slotEpoch[idx] == _epoch) { liveIndex = idx; return true; } } liveIndex = -1; return false; }");
			sb.AppendLine("\t\t[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]");
			sb.AppendLine("\t\tinternal " + typeName + "Handle HandleAtIndexUnchecked(int i) => new " + typeName + "Handle((uint)i, _gen[i]);\n");
			if (model.GenerateStableId)
			{
				sb.AppendLine("\t\tprivate void EnsureHandleToIdCapacity(int size) { if (_handleToId.Length < size) System.Array.Resize(ref _handleToId, size * 2); }");
				sb.AppendLine("\t\tinternal void MapIdToHandle(" + typeName + "Id id, " + typeName + "Handle h) { _idToHandle[id] = h; EnsureHandleToIdCapacity((int)h.Index + 1); _handleToId[(int)h.Index] = id; }");
				sb.AppendLine("\t\tinternal bool TryGetById(" + typeName + "Id id, out " + typeName + "Handle h) => _idToHandle.TryGetValue(id, out h);");
				sb.AppendLine("\t\tinternal bool TryGetId(" + typeName + "Handle h, out " + typeName + "Id id) { EnsureHandleToIdCapacity((int)h.Index + 1); id = _handleToId[(int)h.Index]; return id.Value != 0; }");
				bool hasSidecar = false;
				for (int i = 0; i < model.Columns.Count; i++)
				{
					if (model.Columns[i].Storage != 0)
					{
						hasSidecar = true;
						break;
					}
				}

				if (!model.SoA || !hasSidecar)
				{
					sb.AppendLine("\t\tprivate void UnmapIdForHandle(int idx, " + typeName + "Handle h) { if (TryGetId(h, out var oldId)) { if (_idToHandle.TryGetValue(oldId, out var mapped) && mapped.Equals(h)) _idToHandle.Remove(oldId); } _handleToId[idx] = default; }");
				}
				else
				{
					sb.AppendLine("\t\tprivate void UnmapIdForHandle(int idx, " + typeName + "Handle h)");
					sb.AppendLine("\t\t{");
					sb.AppendLine("\t\t\tif (TryGetId(h, out var oldId))");
					sb.AppendLine("\t\t\t{");
					sb.AppendLine("\t\t\t\tif (_idToHandle.TryGetValue(oldId, out var mapped) && mapped.Equals(h))");
					sb.AppendLine("\t\t\t\t{");
					sb.AppendLine("\t\t\t\t\t_idToHandle.Remove(oldId);");
					sb.AppendLine("\t\t\t\t}");
					sb.AppendLine();
					sb.AppendLine("\t\t\t\tif (oldId.Value != 0 && oldId.Value <= int.MaxValue)");
					sb.AppendLine("\t\t\t\t{");
					sb.AppendLine("\t\t\t\t\tint idIndex = (int)oldId.Value;");
					sb.AppendLine("\t\t\t\t\tif (idIndex > 0)");
					sb.AppendLine("\t\t\t\t\t{");
					for (int i = 0; i < model.Columns.Count; i++)
					{
						var c = model.Columns[i];
						if (c.Storage == 0)
						{
							continue;
						}
						sb.AppendLine("\t\t\t\t\t\tif ((uint)idIndex < (uint)_sc_" + c.Name + ".Length) _sc_" + c.Name + "[idIndex] = default;");
					}
					sb.AppendLine("\t\t\t\t\t}");
					sb.AppendLine("\t\t\t\t}");
					sb.AppendLine("\t\t\t}");
					sb.AppendLine("\t\t\t_handleToId[idx] = default;");
					sb.AppendLine("\t\t}");
				}
			}
			sb.AppendLine("\t}\n");

			// Partial struct container with nested View/Edit/Api
			sb.AppendLine("\tpublic partial struct " + typeName);
			sb.AppendLine("\t{");
				// View
				sb.AppendLine("\t\tpublic readonly struct ViewProxy");
				sb.AppendLine("\t\t{");
				var facadeHeader = "\t\t\tprivate readonly " + typeName + "Pool _p; private readonly " + typeName + "Handle _h; public " + typeName + "Handle Handle => _h; public ViewProxy(" + typeName + "Pool p, " + typeName + "Handle h) { _p = p; _h = h; } public bool IsAlive => _p.IsValid(_h);";
				sb.AppendLine(facadeHeader);
				foreach (var c in model.Columns)
				{
					var colType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					if (model.SoA)
					{
						var getter = c.ReadOnly ? ("get => _p." + c.Name + "Get(_h);") : ("get => _p." + c.Name + "Ref(_h);");
						var setter = c.ReadOnly ? string.Empty : ("set => _p." + c.Name + "Ref(_h) = value;");
						var propLine = "\t\t\tpublic " + colType + " " + c.Name + " { " + getter + (string.IsNullOrEmpty(setter) ? string.Empty : (" " + setter)) + " }";
						sb.AppendLine(propLine);
					}
					else
					{
						sb.AppendLine("\t\t\tpublic ref " + colType + " " + c.Name + " => ref _p.GetRef(_h)." + c.Name + ";");
					}
				}
				foreach (var c in model.Columns)
				{
					if (!TryGetInlineArrayInfo(c.Type, out var elementType, out int inlineLen))
					{
						continue;
					}

					var bufferType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

					sb.AppendLine();
					sb.AppendLine("\t\t\tpublic global::System.Span<" + elementTypeName + "> " + c.Name + "Span()");
					sb.AppendLine("\t\t\t{");
					if (model.SoA)
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p." + c.Name + "Ref(_h);");
					}
					else
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p.GetRef(_h)." + c.Name + ";");
					}
					sb.AppendLine("\t\t\t\treturn global::System.Runtime.InteropServices.MemoryMarshal.CreateSpan(ref buffer[0], " + inlineLen + ");");
					sb.AppendLine("\t\t\t}");

					sb.AppendLine();
					sb.AppendLine("\t\t\tpublic global::System.ReadOnlySpan<" + elementTypeName + "> " + c.Name + "ReadOnlySpan()");
					sb.AppendLine("\t\t\t{");
					if (model.SoA)
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p." + c.Name + "Ref(_h);");
					}
					else
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p.GetRef(_h)." + c.Name + ";");
					}
					sb.AppendLine("\t\t\t\treturn global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref buffer[0], " + inlineLen + ");");
					sb.AppendLine("\t\t\t}");
				}
				sb.AppendLine("\t\t\tpublic Edit Edit() => new Edit(_p, _h);\n\t\t}\n");
				// Edit
				sb.AppendLine("\t\tpublic readonly ref struct Edit");
				sb.AppendLine("\t\t{");
			var editHeader = "\t\t\tprivate readonly " + typeName + "Pool _p; private readonly " + typeName + "Handle _h; private readonly " + typeName + "Pool.BorrowToken _tok; public Edit(" + typeName + "Pool p, " + typeName + "Handle h) { _p = p; _h = h; _tok = p.BorrowEnter(); } public void Dispose() { _tok.Dispose(); }";
			sb.AppendLine(editHeader);
				foreach (var c in model.Columns)
				{
					var colType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					if (model.SoA)
					{
						sb.AppendLine("\t\t\tpublic ref " + colType + " " + c.Name + " => ref _p." + c.Name + "Ref(_h);");
					}
					else
					{
						sb.AppendLine("\t\t\tpublic ref " + colType + " " + c.Name + " => ref _p.GetRef(_h)." + c.Name + ";");
					}
				}
				foreach (var c in model.Columns)
				{
					if (!TryGetInlineArrayInfo(c.Type, out var elementType, out int inlineLen))
					{
						continue;
					}

					var bufferType = c.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
					var elementTypeName = elementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

					sb.AppendLine();
					sb.AppendLine("\t\t\tpublic global::System.Span<" + elementTypeName + "> " + c.Name + "Span()");
					sb.AppendLine("\t\t\t{");
					if (model.SoA)
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p." + c.Name + "Ref(_h);");
					}
					else
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p.GetRef(_h)." + c.Name + ";");
					}
					sb.AppendLine("\t\t\t\treturn global::System.Runtime.InteropServices.MemoryMarshal.CreateSpan(ref buffer[0], " + inlineLen + ");");
					sb.AppendLine("\t\t\t}");

					sb.AppendLine();
					sb.AppendLine("\t\t\tpublic global::System.ReadOnlySpan<" + elementTypeName + "> " + c.Name + "ReadOnlySpan()");
					sb.AppendLine("\t\t\t{");
					if (model.SoA)
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p." + c.Name + "Ref(_h);");
					}
					else
					{
						sb.AppendLine("\t\t\t\tref " + bufferType + " buffer = ref _p.GetRef(_h)." + c.Name + ";");
					}
					sb.AppendLine("\t\t\t\treturn global::System.Runtime.InteropServices.MemoryMarshal.CreateReadOnlySpan(ref buffer[0], " + inlineLen + ");");
					sb.AppendLine("\t\t\t}");
				}
				sb.AppendLine("\t\t}\n");

			// Binding cache (Ref + cached Handle + last seen Version)
			if (model.GenerateStableId)
			{
				sb.AppendLine("\t\tpublic struct Binding");
				sb.AppendLine("\t\t{");
				sb.AppendLine("\t\t\tpublic " + typeName + "Ref Ref;");
				sb.AppendLine("\t\t\tpublic " + typeName + "Handle Handle;");
				sb.AppendLine("\t\t\tpublic uint Version;");
				sb.AppendLine("\t\t\tpublic bool HasHandle;");
				sb.AppendLine("\t\t\tpublic void Reset() { this = default; }");
				sb.AppendLine("\t\t}\n");
			}
			// Api static class with CWT cache and bound Factory
			sb.AppendLine("\t\tpublic static class Api");
			sb.AppendLine("\t\t{");
			sb.AppendLine("\t\t\tpublic const ushort PoolIdConst = " + model.PoolId + ";");
			sb.AppendLine("\t\t\tprivate static readonly global::System.Runtime.CompilerServices.ConditionalWeakTable<global::Pooled.Runtime.IPoolRegistry, " + typeName + "Pool> _cache = new global::System.Runtime.CompilerServices.ConditionalWeakTable<global::Pooled.Runtime.IPoolRegistry, " + typeName + "Pool>();");
			sb.AppendLine("\t\t\tprivate static readonly global::System.Runtime.CompilerServices.ConditionalWeakTable<global::Pooled.Runtime.IPoolRegistry, " + typeName + "Pool>.CreateValueCallback __create = __CreatePool;\n");
			sb.AppendLine("\t\t\tprivate static " + typeName + "Pool __CreatePool(global::Pooled.Runtime.IPoolRegistry reg) => new " + typeName + "Pool(" + (model.InitialCapacity) + ");");
			sb.AppendLine("\t\t\tprivate static " + typeName + "Pool GetPool(global::Pooled.Runtime.IPoolRegistry reg) => _cache.GetValue(reg, __create);\n");
			sb.AppendLine("\t\t\tinternal static " + typeName + "Pool GetPoolForProperties(global::Pooled.Runtime.IPoolRegistry reg) => GetPool(reg);\n");
			// Static convenience methods
			sb.AppendLine("\t\t\tpublic static ViewProxy Create(global::Pooled.Runtime.IPoolRegistry reg, in " + schemaFqn + " init = default) => new ViewProxy(GetPool(reg), GetPool(reg).Allocate(in init));");
			sb.AppendLine("\t\t\tpublic static void Destroy(global::Pooled.Runtime.IPoolRegistry reg, in ViewProxy v) => GetPool(reg).Free(v.Handle);");
			sb.AppendLine("\t\t\tpublic static " + typeName + "Enumerable All(global::Pooled.Runtime.IPoolRegistry reg) => new " + typeName + "Enumerable(GetPool(reg));");
			sb.AppendLine("\t\t\tpublic static ViewProxy FromHandle(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Handle h) => new ViewProxy(GetPool(reg), h);");
			// Alloc-free iteration helpers
			sb.AppendLine("\t\t\tpublic static void ForEach(global::Pooled.Runtime.IPoolRegistry reg, System.Action<" + nestedViewType + "> action) { var p = GetPool(reg); int cursor = 0; while (p.TryNextLive(cursor, out var li)) { action(new ViewProxy(p, p.HandleAtIndexUnchecked(li))); cursor = li + 1; } }");
			sb.AppendLine("\t\t\tpublic static bool TryGetNextLive(global::Pooled.Runtime.IPoolRegistry reg, ref int cursor, out ViewProxy v) { var p = GetPool(reg); if (p.TryNextLive(cursor, out var li)) { cursor = li + 1; v = new ViewProxy(p, p.HandleAtIndexUnchecked(li)); return true; } v = default; return false; }\n");
			// Residency/versioning convenience wrappers
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\tpublic static " + typeName + "Pool.Lease PinCPU(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Handle h) => GetPool(reg).PinCPU(h);");
				sb.AppendLine("\t\t\tpublic static uint VersionGet(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Handle h) => GetPool(reg).VersionGet(h);");
				sb.AppendLine("\t\t\tpublic static ref uint VersionRef(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Handle h) => ref GetPool(reg).VersionRef(h);");
			}
			// Stable ID helpers if enabled
			if (model.GenerateStableId)
			{
				bool hasSidecarColumns = false;
				if (model.SoA)
				{
					for (int i = 0; i < model.Columns.Count; i++)
					{
						if (model.Columns[i].Storage != 0)
						{
							hasSidecarColumns = true;
							break;
						}
					}
				}

				string initSidecarCreate = hasSidecarColumns ? " p.InitSidecarFromInit(h, in init);" : string.Empty;
				string initSidecarGetOrCreate = hasSidecarColumns ? " p.InitSidecarFromInit(newH, in init);" : string.Empty;
				sb.AppendLine("\t\t\tpublic static ViewProxy CreateWithId(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Id id, in " + schemaFqn + " init = default) { var p = GetPool(reg); var h = p.Allocate(in init); p.MapIdToHandle(id, h);" + initSidecarCreate + " return new ViewProxy(p, h); }");
				sb.AppendLine("\t\t\tpublic static ViewProxy GetOrCreateById(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Id id, in " + schemaFqn + " init = default) { var p = GetPool(reg); if (p.TryGetById(id, out var h) && p.IsValid(h)) { return new ViewProxy(p, h); } var newH = p.Allocate(in init); p.MapIdToHandle(id, newH);" + initSidecarGetOrCreate + " return new ViewProxy(p, newH); }");
				sb.AppendLine("\t\t\tpublic static bool TryGetById(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Id id, out ViewProxy v) { var p = GetPool(reg); if (p.TryGetById(id, out var h) && p.IsValid(h)) { v = new ViewProxy(p, h); return true; } v = default; return false; }");
				sb.AppendLine("\t\t\tpublic static bool TryGetHandleById(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Id id, out " + typeName + "Handle h) { var p = GetPool(reg); if (p.TryGetById(id, out h) && p.IsValid(h)) { return true; } h = default; return false; }");
				sb.AppendLine("\t\t\tpublic static bool TryResolve(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Id id, out ViewProxy v) => TryGetById(reg, id, out v);");
				sb.AppendLine("\t\t\tpublic static bool TryGetId(global::Pooled.Runtime.IPoolRegistry reg, in ViewProxy v, out " + typeName + "Id id) { var p = GetPool(reg); return p.TryGetId(v.Handle, out id); }\n");
				// Ref-based resolve helpers
				sb.AppendLine("\t\t\tpublic static " + nestedViewType + " Resolve(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Ref r, in " + schemaFqn + " init = default) => GetOrCreateById(reg, r.Id, in init);");
				sb.AppendLine("\t\t\tpublic static bool TryResolve(global::Pooled.Runtime.IPoolRegistry reg, " + typeName + "Ref r, out " + nestedViewType + " v) => TryGetById(reg, r.Id, out v);\n");
				// Ensure: resolve Ref -> Handle (if needed), get View, detect hot-reload
				sb.AppendLine("\t\t\tpublic static bool Ensure(global::Pooled.Runtime.IPoolRegistry reg, ref " + typeName + ".Binding b, in " + schemaFqn + " init, out " + nestedViewType + " v, out bool updated)");
				sb.AppendLine("\t\t\t{");
				sb.AppendLine("\t\t\t\tupdated = false;");
				sb.AppendLine("\t\t\t\tif (!b.HasHandle || !FromHandle(reg, b.Handle).IsAlive)");
				sb.AppendLine("\t\t\t\t{");
				sb.AppendLine("\t\t\t\t\tv = GetOrCreateById(reg, b.Ref.Id, in init);");
				sb.AppendLine("\t\t\t\t\tb.Handle = v.Handle;");
				if (model.RefCounting != 0)
				{
					sb.AppendLine("\t\t\t\t\tb.Version = VersionGet(reg, b.Handle);");
				}
				sb.AppendLine("\t\t\t\t\tb.HasHandle = true;");
				sb.AppendLine("\t\t\t\t\tupdated = true;");
				sb.AppendLine("\t\t\t\t\treturn true;");
				sb.AppendLine("\t\t\t\t}");
				sb.AppendLine("\t\t\t\tv = FromHandle(reg, b.Handle);");
				if (model.RefCounting != 0)
				{
					sb.AppendLine("\t\t\t\tvar cur = VersionGet(reg, b.Handle);");
					sb.AppendLine("\t\t\t\tif (cur != b.Version) { b.Version = cur; updated = true; }");
				}
				sb.AppendLine("\t\t\t\treturn true;");
				sb.AppendLine("\t\t\t}\n");

				// Use with Action<ViewProxy>
				sb.AppendLine("\t\t\tpublic static bool Use(global::Pooled.Runtime.IPoolRegistry reg, ref " + typeName + ".Binding b, System.Action<" + nestedViewType + "> action, in " + schemaFqn + " init = default)");
				sb.AppendLine("\t\t\t{");
				sb.AppendLine("\t\t\t\t_ = Ensure(reg, ref b, in init, out var v, out _);");
				if (model.RefCounting != 0)
				{
					sb.AppendLine("\t\t\t\tusing var __lease = PinCPU(reg, v.Handle);");
				}
				sb.AppendLine("\t\t\t\taction(v);");
				sb.AppendLine("\t\t\t\treturn true;");
				sb.AppendLine("\t\t\t}\n");

				// Use with out bool updated
				sb.AppendLine("\t\t\tpublic static bool Use(global::Pooled.Runtime.IPoolRegistry reg, ref " + typeName + ".Binding b, out bool updated, System.Action<" + nestedViewType + "> action, in " + schemaFqn + " init = default)");
				sb.AppendLine("\t\t\t{");
				sb.AppendLine("\t\t\t\t_ = Ensure(reg, ref b, in init, out var v, out updated);");
				if (model.RefCounting != 0)
				{
					sb.AppendLine("\t\t\t\tusing var __lease = PinCPU(reg, v.Handle);");
				}
				sb.AppendLine("\t\t\t\taction(v);");
				sb.AppendLine("\t\t\t\treturn true;");
				sb.AppendLine("\t\t\t}\n");

				// Use<TState>
				sb.AppendLine("\t\t\tpublic static bool Use<TState>(global::Pooled.Runtime.IPoolRegistry reg, ref " + typeName + ".Binding b, TState state, System.Action<TState, " + nestedViewType + "> action, in " + schemaFqn + " init = default)");
				sb.AppendLine("\t\t\t{");
				sb.AppendLine("\t\t\t\t_ = Ensure(reg, ref b, in init, out var v, out _);");
				if (model.RefCounting != 0)
				{
					sb.AppendLine("\t\t\t\tusing var __lease = PinCPU(reg, v.Handle);");
				}
				sb.AppendLine("\t\t\t\taction(state, v);");
				sb.AppendLine("\t\t\t\treturn true;");
				sb.AppendLine("\t\t\t}\n");

				// Convenience creators
				sb.AppendLine("\t\t\tpublic static " + typeName + "Ref RefFromId(" + typeName + "Id id) => new " + typeName + "Ref(id);");
				sb.AppendLine("\t\t\tpublic static " + typeName + "Id IdFrom(ulong value) => new " + typeName + "Id(value);");
				sb.AppendLine("\t\t\tpublic static " + typeName + ".Binding BindingFromId(" + typeName + "Id id) { var b = new " + typeName + ".Binding(); b.Ref = new " + typeName + "Ref(id); b.Handle = default; b.Version = 0; b.HasHandle = false; return b; }\n");
				sb.AppendLine("\t\t\tpublic static " + typeName + ".Binding BindingFrom(ulong value) { var b = new " + typeName + ".Binding(); b.Ref = new " + typeName + "Ref(new " + typeName + "Id(value)); b.Handle = default; b.Version = 0; b.HasHandle = false; return b; }\n");
			}
			// Bound Factory
			sb.AppendLine("\t\t\tpublic static Factory Bind(global::Pooled.Runtime.IPoolRegistry reg) => new Factory(GetPool(reg));");
			sb.AppendLine("\t\t\tpublic readonly struct Factory");
			sb.AppendLine("\t\t\t{\n\t\t\t\tprivate readonly " + typeName + "Pool _p;\n\t\t\t\tinternal Factory(" + typeName + "Pool p) { _p = p; }\n\t\t\t\tpublic ViewProxy Create(in " + schemaFqn + " init = default) => new ViewProxy(_p, _p.Allocate(in init));\n\t\t\t\tpublic ViewProxy FromHandle(" + typeName + "Handle h) => new ViewProxy(_p, h);\n\t\t\t\tpublic void Destroy(in ViewProxy v) => _p.Free(v.Handle);\n\t\t\t\tpublic " + typeName + "Enumerable All() => new " + typeName + "Enumerable(_p);\n\t\t\t\tpublic void ForEach(System.Action<" + nestedViewType + "> action) { int cursor = 0; while (_p.TryNextLive(cursor, out var li)) { action(new ViewProxy(_p, _p.HandleAtIndexUnchecked(li))); cursor = li + 1; } }\n\t\t\t\tpublic bool TryGetNextLive(ref int cursor, out ViewProxy v) { if (_p.TryNextLive(cursor, out var li)) { cursor = li + 1; v = new ViewProxy(_p, _p.HandleAtIndexUnchecked(li)); return true; } v = default; return false; }");
			if (model.RefCounting != 0)
			{
				sb.AppendLine("\t\t\t\tpublic System.IDisposable PinCPU(" + typeName + "Handle h) => _p.PinCPU(h);");
				sb.AppendLine("\t\t\t\tpublic uint VersionGet(" + typeName + "Handle h) => _p.VersionGet(h);");
			}
			if (model.GenerateStableId)
			{
				bool hasSidecarColumns = false;
				if (model.SoA)
				{
					for (int i = 0; i < model.Columns.Count; i++)
					{
						if (model.Columns[i].Storage != 0)
						{
							hasSidecarColumns = true;
							break;
						}
					}
				}

				string initSidecarCreate = hasSidecarColumns ? " _p.InitSidecarFromInit(h, in init);" : string.Empty;
				string initSidecarGetOrCreate = hasSidecarColumns ? " _p.InitSidecarFromInit(newH, in init);" : string.Empty;
				sb.AppendLine("\t\t\t\tpublic ViewProxy CreateWithId(" + typeName + "Id id, in " + schemaFqn + " init = default) { var h = _p.Allocate(in init); _p.MapIdToHandle(id, h);" + initSidecarCreate + " return new ViewProxy(_p, h); }");
				sb.AppendLine("\t\t\t\tpublic ViewProxy GetOrCreateById(" + typeName + "Id id, in " + schemaFqn + " init = default) { if (_p.TryGetById(id, out var h) && _p.IsValid(h)) { return new ViewProxy(_p, h); } var newH = _p.Allocate(in init); _p.MapIdToHandle(id, newH);" + initSidecarGetOrCreate + " return new ViewProxy(_p, newH); }");
				sb.AppendLine("\t\t\t\tpublic bool TryGetById(" + typeName + "Id id, out ViewProxy v) { if (_p.TryGetById(id, out var h) && _p.IsValid(h)) { v = new ViewProxy(_p, h); return true; } v = default; return false; }");
				sb.AppendLine("\t\t\t\tpublic bool TryResolve(" + typeName + "Id id, out ViewProxy v) => TryGetById(id, out v);");
				sb.AppendLine("\t\t\t\tpublic bool TryGetId(in ViewProxy v, out " + typeName + "Id id) => _p.TryGetId(v.Handle, out id);");
				// Ref-based helpers on bound factory
				sb.AppendLine("\t\t\t\tpublic " + nestedViewType + " Resolve(" + typeName + "Ref r, in " + schemaFqn + " init = default) => GetOrCreateById(r.Id, in init);");
				sb.AppendLine("\t\t\t\tpublic bool TryResolve(" + typeName + "Ref r, out " + nestedViewType + " v) => TryGetById(r.Id, out v);");
				// Convenience creators on bound factory
				sb.AppendLine("\t\t\t\tpublic " + typeName + "Ref RefFromId(" + typeName + "Id id) => new " + typeName + "Ref(id);");
				sb.AppendLine("\t\t\t\tpublic " + typeName + "Id IdFrom(ulong value) => new " + typeName + "Id(value);");
				sb.AppendLine("\t\t\t\tpublic " + typeName + ".Binding BindingFromId(" + typeName + "Id id) { var b = new " + typeName + ".Binding(); b.Ref = new " + typeName + "Ref(id); b.Handle = default; b.Version = 0; b.HasHandle = false; return b; }");
				sb.AppendLine("\t\t\t\tpublic " + typeName + ".Binding BindingFrom(ulong value) { var b = new " + typeName + ".Binding(); b.Ref = new " + typeName + "Ref(new " + typeName + "Id(value)); b.Handle = default; b.Version = 0; b.HasHandle = false; return b; }");
			}
			sb.AppendLine("\t\t\t}\n");
			sb.AppendLine("\t\t}\n");
			// end partial struct
			sb.AppendLine("\t}\n");

			// Enumerable
			sb.AppendLine("\tpublic readonly struct " + typeName + "Enumerable");
			sb.AppendLine("\t{ public readonly " + typeName + "Pool _p; public " + typeName + "Enumerable(" + typeName + "Pool p){_p=p;} public " + typeName + "Enumerator GetEnumerator()=>new " + typeName + "Enumerator(_p);} ");
			sb.AppendLine("\tpublic struct " + typeName + "Enumerator");
			sb.AppendLine("\t{ private readonly " + typeName + "Pool _p; private int _cursor; private int _curIdx; internal " + typeName + "Enumerator(" + typeName + "Pool p){_p=p;_cursor=0;_curIdx=-1;} ");
			sb.AppendLine("\t\tpublic " + nestedViewType + " Current => new " + nestedViewType + "(_p,_p.HandleAtIndexUnchecked(_curIdx));");
			sb.AppendLine("\t\t[System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public bool MoveNext(){int c=_cursor; if(_p.TryNextLive(c,out var idx)){_cursor=c+1; _curIdx=idx; return true;} return false;} }");

			if (!string.IsNullOrEmpty(ns) && ns != "global::")
			{
				sb.AppendLine("}");
			}

			return sb.ToString();
		}

		private static bool TryGetInlineArrayInfo(ITypeSymbol typeSymbol, out ITypeSymbol elementType, out int length)
		{
			elementType = typeSymbol;
			length = 0;

			if (typeSymbol is not INamedTypeSymbol namedType)
			{
				return false;
			}

			const string inlineArrayAttributeName = "global::System.Runtime.CompilerServices.InlineArrayAttribute";
			foreach (var attr in namedType.GetAttributes())
			{
				if (attr.AttributeClass == null)
				{
					continue;
				}

				string attrName = attr.AttributeClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
				if (attrName != inlineArrayAttributeName)
				{
					continue;
				}

				if (attr.ConstructorArguments.Length == 1 &&
				    attr.ConstructorArguments[0].Kind == TypedConstantKind.Primitive &&
				    attr.ConstructorArguments[0].Value is int lenValue &&
				    lenValue > 0)
				{
					length = lenValue;
				}
				break;
			}

			if (length <= 0)
			{
				return false;
			}

			foreach (var member in namedType.GetMembers())
			{
				if (member is not IFieldSymbol field)
				{
					continue;
				}

				if (field.IsStatic)
				{
					continue;
				}

				elementType = field.Type;
				return true;
			}

			return false;
		}
	}
}
