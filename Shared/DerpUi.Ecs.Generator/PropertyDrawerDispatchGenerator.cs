using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DerpUi.Ecs.Generator;

[Generator]
public sealed class PropertyDrawerDispatchGenerator : IIncrementalGenerator
{
    private const string PropertyDrawerAttributeMetadataName = "Property.PropertyDrawerAttribute";
    private const string Vector4MetadataName = "System.Numerics.Vector4";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<DrawerTarget> targets = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: PropertyDrawerAttributeMetadataName,
                // Field attributes are reported against the field symbol; the syntax node is typically the variable declarator.
                predicate: static (node, _) => node is VariableDeclaratorSyntax,
                transform: static (syntaxContext, _) => TryGetTarget(syntaxContext))
            .Where(static target => target.IsValid);

        IncrementalValueProvider<ImmutableArray<DrawerTarget>> allTargets = targets.Collect();

        context.RegisterSourceOutput(allTargets, static (sourceContext, collected) =>
        {
            Emit(sourceContext, collected);
        });
    }

    private static DrawerTarget TryGetTarget(GeneratorAttributeSyntaxContext syntaxContext)
    {
        if (syntaxContext.TargetSymbol is not IFieldSymbol fieldSymbol)
        {
            return default;
        }

        if (fieldSymbol.ContainingType is not INamedTypeSymbol componentSymbol)
        {
            return default;
        }

        // For now, only support Vector4 drawers (Insets/CornerRadius).
        string fieldTypeName = fieldSymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (fieldTypeName != "global::" + Vector4MetadataName)
        {
            return default;
        }

        INamedTypeSymbol? drawerType = null;
        int options = 0;
        foreach (AttributeData attributeData in syntaxContext.Attributes)
        {
            if (attributeData.AttributeClass == null)
            {
                continue;
            }

            if (attributeData.AttributeClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) != "global::" + PropertyDrawerAttributeMetadataName)
            {
                continue;
            }

            if (attributeData.ConstructorArguments.Length >= 1 &&
                attributeData.ConstructorArguments[0].Kind == TypedConstantKind.Type &&
                attributeData.ConstructorArguments[0].Value is INamedTypeSymbol drawerTypeSymbol)
            {
                drawerType = drawerTypeSymbol;
            }

            if (attributeData.ConstructorArguments.Length >= 2 &&
                attributeData.ConstructorArguments[1].Kind == TypedConstantKind.Primitive &&
                attributeData.ConstructorArguments[1].Value is int opt)
            {
                options = opt;
            }

            break;
        }

        if (drawerType == null)
        {
            return default;
        }

        string componentTypeName = componentSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        string propertyPath = componentTypeName + "." + fieldSymbol.Name;
        ulong propertyId = ComputeFnv1a(propertyPath);

        string drawerTypeName = drawerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return new DrawerTarget(propertyId, drawerTypeName, options);
    }

    private static void Emit(SourceProductionContext context, ImmutableArray<DrawerTarget> targets)
    {
        var ordered = new List<DrawerTarget>(targets.IsDefault ? 0 : targets.Length);
        if (!targets.IsDefaultOrEmpty)
        {
            for (int i = 0; i < targets.Length; i++)
            {
                DrawerTarget target = targets[i];
                if (target.IsValid)
                {
                    ordered.Add(target);
                }
            }
        }

        ordered.Sort(static (left, right) =>
        {
            return left.PropertyId.CompareTo(right.PropertyId);
        });

        var sb = new StringBuilder(capacity: 8192);
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Numerics;");
        sb.AppendLine("using DerpLib.ImGui;");
        sb.AppendLine("using Property.Runtime;");
        sb.AppendLine();
        sb.AppendLine("namespace Derp.UI;");
        sb.AppendLine();
        sb.AppendLine("internal sealed partial class PropertyInspector");
        sb.AppendLine("{");
        sb.AppendLine("    private bool TryDrawGeneratedDrawerSingle(in PropertyUiItem item, PropertySlot slot, float labelWidth, float inputWidth)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (slot.PropertyId)");
        sb.AppendLine("        {");

        for (int i = 0; i < ordered.Count; i++)
        {
            DrawerTarget target = ordered[i];
            sb.Append("            case 0x").Append(target.PropertyId.ToString("X16", CultureInfo.InvariantCulture)).AppendLine("UL:");
            sb.AppendLine("            {");
            sb.AppendLine("                Vector4 value = PropertyDispatcher.ReadVec4(_propertyWorld, slot);");
            sb.AppendLine("                float minValue = float.IsNaN(item.Info.Min) ? float.MinValue : item.Info.Min;");
            sb.AppendLine("                float maxValue = float.IsNaN(item.Info.Max) ? float.MaxValue : item.Info.Max;");
            sb.AppendLine("                bool changed = " + target.DrawerTypeName + ".Draw(item.Label, item.WidgetId, labelWidth, inputWidth, minValue, maxValue, InspectorRowPaddingX, options: " + target.Options.ToString(CultureInfo.InvariantCulture) + ", mixedMask: 0u, ref value, out bool isEditing);");
            sb.AppendLine("                int widgetId = Im.Context.GetId(item.WidgetId);");
            sb.AppendLine("                if (changed)");
            sb.AppendLine("                {");
            sb.AppendLine("                    _commands.SetPropertyValue(widgetId, isEditing, slot, PropertyValue.FromVec4(value));");
            sb.AppendLine("                }");
            sb.AppendLine("                else");
            sb.AppendLine("                {");
            sb.AppendLine("                    _commands.NotifyPropertyWidgetState(widgetId, isEditing);");
            sb.AppendLine("                }");
            sb.AppendLine("                return true;");
            sb.AppendLine("            }");
        }

        sb.AppendLine("            default:");
        sb.AppendLine("                return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private bool TryDrawGeneratedDrawerMulti(in PropertyUiItem item, AnyComponentHandle component0, ReadOnlySpan<AnyComponentHandle> components, PropertySlot slot0, float labelWidth, float inputWidth)");
        sb.AppendLine("    {");
        sb.AppendLine("        switch (slot0.PropertyId)");
        sb.AppendLine("        {");

        for (int i = 0; i < ordered.Count; i++)
        {
            DrawerTarget target = ordered[i];
            sb.Append("            case 0x").Append(target.PropertyId.ToString("X16", CultureInfo.InvariantCulture)).AppendLine("UL:");
            sb.AppendLine("            {");
            sb.AppendLine("                Vector4 value = PropertyDispatcher.ReadVec4(_propertyWorld, slot0);");
            sb.AppendLine("                Vector4 before = value;");
            sb.AppendLine("                uint mixedMask = 0u;");
            sb.AppendLine("                for (int i = 1; i < components.Length; i++)");
            sb.AppendLine("                {");
            sb.AppendLine("                    if (!TryResolveSlotForMulti(components[i], slot0.PropertyIndex, slot0.PropertyId, slot0.Kind, out PropertySlot slot))");
            sb.AppendLine("                    {");
            sb.AppendLine("                        return true;");
            sb.AppendLine("                    }");
            sb.AppendLine("                    Vector4 current = PropertyDispatcher.ReadVec4(_propertyWorld, slot);");
            sb.AppendLine("                    if (current.X != value.X) { mixedMask |= 1u; }");
            sb.AppendLine("                    if (current.Y != value.Y) { mixedMask |= 2u; }");
            sb.AppendLine("                    if (current.Z != value.Z) { mixedMask |= 4u; }");
            sb.AppendLine("                    if (current.W != value.W) { mixedMask |= 8u; }");
            sb.AppendLine("                }");
            sb.AppendLine();
            sb.AppendLine("                float minValue = float.IsNaN(item.Info.Min) ? float.MinValue : item.Info.Min;");
            sb.AppendLine("                float maxValue = float.IsNaN(item.Info.Max) ? float.MaxValue : item.Info.Max;");
            sb.AppendLine("                bool changed = " + target.DrawerTypeName + ".Draw(item.Label, item.WidgetId, labelWidth, inputWidth, minValue, maxValue, InspectorRowPaddingX, options: " + target.Options.ToString(CultureInfo.InvariantCulture) + ", mixedMask, ref value, out bool isEditing);");
            sb.AppendLine("                int widgetId = Im.Context.GetId(item.WidgetId);");
            sb.AppendLine();
            sb.AppendLine("                uint changedMask = 0u;");
            sb.AppendLine("                if (value.X != before.X) { changedMask |= 1u; }");
            sb.AppendLine("                if (value.Y != before.Y) { changedMask |= 2u; }");
            sb.AppendLine("                if (value.Z != before.Z) { changedMask |= 4u; }");
            sb.AppendLine("                if (value.W != before.W) { changedMask |= 8u; }");
            sb.AppendLine();
            sb.AppendLine("                if (changed && changedMask != 0u)");
            sb.AppendLine("                {");
            sb.AppendLine("                    EnsureMultiScratchCapacity(components.Length);");
            sb.AppendLine("                    _multiSlotsScratch[0] = slot0;");
            sb.AppendLine("                    for (int i = 1; i < components.Length; i++)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        if (!TryResolveSlotForMulti(components[i], slot0.PropertyIndex, slot0.PropertyId, slot0.Kind, out PropertySlot slot))");
            sb.AppendLine("                        {");
            sb.AppendLine("                            return true;");
            sb.AppendLine("                        }");
            sb.AppendLine("                        _multiSlotsScratch[i] = slot;");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    EnsureMultiScratchCapacity(components.Length);");
            sb.AppendLine("                    for (int i = 0; i < components.Length; i++)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        Vector4 current = PropertyDispatcher.ReadVec4(_propertyWorld, _multiSlotsScratch[i]);");
            sb.AppendLine("                        if ((changedMask & 1u) != 0u) { current.X = value.X; }");
            sb.AppendLine("                        if ((changedMask & 2u) != 0u) { current.Y = value.Y; }");
            sb.AppendLine("                        if ((changedMask & 4u) != 0u) { current.Z = value.Z; }");
            sb.AppendLine("                        if ((changedMask & 8u) != 0u) { current.W = value.W; }");
            sb.AppendLine("                        _multiValuesScratch[i] = PropertyValue.FromVec4(current);");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    _commands.SetPropertyValuesMany(widgetId, isEditing, _multiSlotsScratch.AsSpan(0, components.Length), _multiValuesScratch.AsSpan(0, components.Length));");
            sb.AppendLine("                }");
            sb.AppendLine("                else");
            sb.AppendLine("                {");
            sb.AppendLine("                    _commands.NotifyPropertyWidgetState(widgetId, isEditing);");
            sb.AppendLine("                }");
            sb.AppendLine("                return true;");
            sb.AppendLine("            }");
        }

        sb.AppendLine("            default:");
        sb.AppendLine("                return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("PropertyInspector.Drawers.g.cs", sb.ToString());
    }

    private static ulong ComputeFnv1a(string text)
    {
        const ulong fnvOffset = 14695981039346656037UL;
        const ulong fnvPrime = 1099511628211UL;

        ulong hash = fnvOffset;
        for (int i = 0; i < text.Length; i++)
        {
            // Property.Generator hashes UTF8 bytes; for ASCII property paths (component/type/field names),
            // hashing UTF-16 code units matches the byte values.
            // This keeps the generator allocation-free and deterministic across platforms.
            char c = text[i];
            if (c <= 0x7F)
            {
                hash ^= (byte)c;
                hash *= fnvPrime;
                continue;
            }

            // Fallback for non-ASCII.
            return ComputeFnv1aUtf8(text);
        }

        return hash;
    }

    private static ulong ComputeFnv1aUtf8(string text)
    {
        const ulong fnvOffset = 14695981039346656037UL;
        const ulong fnvPrime = 1099511628211UL;

        byte[] bytes = Encoding.UTF8.GetBytes(text);
        ulong hash = fnvOffset;
        for (int i = 0; i < bytes.Length; i++)
        {
            hash ^= bytes[i];
            hash *= fnvPrime;
        }

        return hash;
    }

    private readonly struct DrawerTarget
    {
        public readonly ulong PropertyId;
        public readonly string DrawerTypeName;
        public readonly int Options;

        public bool IsValid => PropertyId != 0 && DrawerTypeName.Length != 0;

        public DrawerTarget(ulong propertyId, string drawerTypeName, int options)
        {
            PropertyId = propertyId;
            DrawerTypeName = drawerTypeName;
            Options = options;
        }
    }
}
