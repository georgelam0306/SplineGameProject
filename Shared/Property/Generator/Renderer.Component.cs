// SPDX-License-Identifier: MIT
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Property.Generator
{
    internal static class ComponentRenderer
    {
        public static string Render(PropertyComponentModel model)
        {
            var builder = new StringBuilder(32_768);
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");

            string namespaceName = model.ComponentSymbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::";
            bool hasNamespace = !string.IsNullOrEmpty(namespaceName) && namespaceName != "global::";
            if (hasNamespace)
            {
                builder.Append("namespace ").Append(namespaceName.Replace("global::", string.Empty)).AppendLine();
                builder.AppendLine("{");
            }

            string componentName = model.ComponentSymbol.Name;
            string propertiesClassName = componentName + "Properties";
            string componentHandleName = componentName + "Handle";
            string poolName = componentName + "Pool";
            string componentTypeName = model.ComponentSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

            builder.AppendLine("\tpublic static class " + propertiesClassName);
            builder.AppendLine("\t{");

            ulong schemaId = PropertyIdHelper.Compute(componentTypeName);
            builder.AppendLine("\t\tpublic const ulong SchemaId = 0x" + schemaId.ToString("X16", CultureInfo.InvariantCulture) + "UL;");
            builder.AppendLine("\t\tpublic const int PropertyCount = " + model.Properties.Count.ToString(CultureInfo.InvariantCulture) + ";");

            builder.AppendLine();
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\tpublic const ulong " + leaf.Identifier + "Id = 0x" + leaf.PropertyId.ToString("X16", CultureInfo.InvariantCulture) + "UL;");
            }

            builder.AppendLine();
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\tprivate static global::Core.StringHandle _name" + leaf.Identifier + ";");
                builder.AppendLine("\t\tprivate static global::Core.StringHandle _group" + leaf.Identifier + ";");
                builder.AppendLine("\t\tprivate static global::Property.Runtime.PropertyInfo _info" + leaf.Identifier + ";");
            }

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static void RegisterNames()");
            builder.AppendLine("\t\t{");
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\t\t_name" + leaf.Identifier + " = \"" + EscapeString(leaf.DisplayName) + "\";");
                builder.AppendLine("\t\t\t_group" + leaf.Identifier + " = \"" + EscapeString(leaf.GroupName) + "\";");
                builder.AppendLine(
                    "\t\t\t_info" + leaf.Identifier + " = new global::Property.Runtime.PropertyInfo(" +
                    leaf.Identifier + "Id, _name" + leaf.Identifier + ", " +
                    PropertyTypeMap.GetKindLiteral(leaf.Kind) + ", _group" + leaf.Identifier + ", " +
                    leaf.Order.ToString(CultureInfo.InvariantCulture) + ", " +
                    FormatFloat(leaf.Min) + ", " +
                    FormatFloat(leaf.Max) + ", " +
                    FormatFloat(leaf.Step) + ", " +
                    PropertyTypeMap.GetFlagsLiteral(leaf.Flags) + ", " +
                    (leaf.HasChannels ? "true" : "false") + ", " +
                    (leaf.IsChannel ? "true" : "false") + ", " +
                    "0x" + leaf.ChannelGroupId.ToString("X16", CultureInfo.InvariantCulture) + "UL, " +
                    "(ushort)" + leaf.ChannelIndex.ToString(CultureInfo.InvariantCulture) + ", " +
                    "(ushort)" + leaf.ChannelCount.ToString(CultureInfo.InvariantCulture) + ");");
            }
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\tpublic static ref readonly global::Property.Runtime.PropertyInfo " + leaf.Identifier + "Info");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\tget { return ref _info" + leaf.Identifier + "; }");
                builder.AppendLine("\t\t}");
            }

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static bool TryGetInfoByIndex(int index, out global::Property.Runtime.PropertyInfo info)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (index)");
            builder.AppendLine("\t\t\t{");
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\t\t\tcase " + leaf.Index.ToString(CultureInfo.InvariantCulture) + ":");
                builder.AppendLine("\t\t\t\t\tinfo = _info" + leaf.Identifier + ";");
                builder.AppendLine("\t\t\t\t\treturn true;");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tinfo = default;");
            builder.AppendLine("\t\t\t\t\treturn false;");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static global::Property.Runtime.PropertySlot GetSlotByIndex(global::Property.Runtime.AnyComponentHandle component, int index)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (index)");
            builder.AppendLine("\t\t\t{");
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\t\t\tcase " + leaf.Index.ToString(CultureInfo.InvariantCulture) + ":");
                builder.AppendLine("\t\t\t\t\treturn new global::Property.Runtime.PropertySlot(component, (ushort)" +
                                   leaf.Index.ToString(CultureInfo.InvariantCulture) + ", " +
                                   leaf.Identifier + "Id, " +
                                   PropertyTypeMap.GetKindLiteral(leaf.Kind) + ");");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid property index.\");");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static " + componentHandleName + " ToTypedHandle(global::Property.Runtime.AnyComponentHandle handle)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\treturn new " + componentHandleName + "(handle.Index, handle.Generation);");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static global::Property.Runtime.AnyComponentHandle ToAnyHandle(" + componentHandleName + " handle)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\treturn new global::Property.Runtime.AnyComponentHandle(" + componentName + ".Api.PoolIdConst, handle.Index, handle.Generation);");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            foreach (var leaf in model.Properties)
            {
                builder.AppendLine("\t\tinternal readonly struct " + leaf.Identifier + "Handle");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\tpublic readonly " + componentHandleName + " Component;");
                builder.AppendLine("\t\t\tpublic " + leaf.Identifier + "Handle(" + componentHandleName + " component)");
                builder.AppendLine("\t\t\t{");
                builder.AppendLine("\t\t\t\tComponent = component;");
                builder.AppendLine("\t\t\t}");
                builder.AppendLine("\t\t}");
                builder.AppendLine();
            }

            foreach (var leaf in model.Properties)
            {
                string leafTypeName = leaf.LeafType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                builder.AppendLine("\t\tpublic static ref " + leafTypeName + " " + leaf.Identifier + "Ref(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component)");
                builder.AppendLine("\t\t{");
                AppendRefAccessor(builder, model, leaf, componentName, poolName, componentTypeName, componentHandleName);
                builder.AppendLine("\t\t}");

                builder.AppendLine();
                builder.AppendLine("\t\tinternal static ref " + leafTypeName + " " + leaf.Identifier + "Ref(global::Pooled.Runtime.IPoolRegistry reg, " + leaf.Identifier + "Handle handle)");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\treturn ref " + leaf.Identifier + "Ref(reg, handle.Component);");
                builder.AppendLine("\t\t}");
                builder.AppendLine();
            }

            RenderIndexAccessors(builder, model, componentName, componentHandleName);

            RenderArrayAccessors(builder, model, componentName, poolName, componentHandleName);

            builder.AppendLine("\t}");

            if (hasNamespace)
            {
                builder.AppendLine("}");
            }

            return builder.ToString();
        }

        private static void RenderIndexAccessors(StringBuilder builder, PropertyComponentModel model, string componentName, string componentHandleName)
        {
            var leavesByKind = new Dictionary<PropertyKind, List<PropertyLeafModel>>();
            foreach (var leaf in model.Properties)
            {
                if (!leavesByKind.TryGetValue(leaf.Kind, out var list))
                {
                    list = new List<PropertyLeafModel>();
                    leavesByKind.Add(leaf.Kind, list);
                }
                list.Add(leaf);
            }

            foreach (var entry in leavesByKind)
            {
                PropertyKind kind = entry.Key;
                string typeName = PropertyTypeMap.GetTypeName(kind);
                string kindName = kind.ToString();

                builder.AppendLine("\t\tpublic static " + typeName + " Get" + kindName + "ByIndex(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component, ushort index)");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\tswitch (index)");
                builder.AppendLine("\t\t\t{");
                foreach (var leaf in entry.Value)
                {
                    builder.AppendLine("\t\t\t\tcase " + leaf.Index.ToString(CultureInfo.InvariantCulture) + ":");
                    builder.AppendLine("\t\t\t\t\treturn " + leaf.Identifier + "Ref(reg, component);");
                }
                builder.AppendLine("\t\t\t\tdefault:");
                builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid property index.\");");
                builder.AppendLine("\t\t\t}");
                builder.AppendLine("\t\t}");

                builder.AppendLine();
                builder.AppendLine("\t\tpublic static void Set" + kindName + "ByIndex(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component, ushort index, " + typeName + " value)");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\tswitch (index)");
                builder.AppendLine("\t\t\t{");
                foreach (var leaf in entry.Value)
                {
                    builder.AppendLine("\t\t\t\tcase " + leaf.Index.ToString(CultureInfo.InvariantCulture) + ":");
                    builder.AppendLine("\t\t\t\t\t" + leaf.Identifier + "Ref(reg, component) = value;");
                    builder.AppendLine("\t\t\t\t\treturn;");
                }
                builder.AppendLine("\t\t\t\tdefault:");
                builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid property index.\");");
                builder.AppendLine("\t\t\t}");
                builder.AppendLine("\t\t}");

                builder.AppendLine();
            }
        }

        private static void RenderArrayAccessors(
            StringBuilder builder,
            PropertyComponentModel model,
            string componentName,
            string poolName,
            string componentHandleName)
        {
            if (model.ArrayFields.Count == 0)
            {
                return;
            }

            builder.AppendLine();
            builder.AppendLine("\t\t// Fixed-size array helpers (generated from [Property.Array]/[Property.Array2D]).");

            for (int i = 0; i < model.ArrayFields.Count; i++)
            {
                var arrayField = model.ArrayFields[i];
                if (!TryResolveArrayElementType(model, arrayField.FieldName, out string elementTypeName))
                {
                    continue;
                }

                string idSegment = NameFormatter.ToIdentifierSegment(arrayField.FieldName);
                int length = arrayField.ArrayValues.IsArray2D ? arrayField.ArrayValues.TotalLength : arrayField.ArrayValues.Length;

                builder.AppendLine();
                builder.AppendLine("\t\tpublic const int " + idSegment + "Length = " + length.ToString(CultureInfo.InvariantCulture) + ";");
                if (arrayField.ArrayValues.IsArray2D)
                {
                    builder.AppendLine("\t\tpublic const int " + idSegment + "Rows = " + arrayField.ArrayValues.Rows.ToString(CultureInfo.InvariantCulture) + ";");
                    builder.AppendLine("\t\tpublic const int " + idSegment + "Cols = " + arrayField.ArrayValues.Cols.ToString(CultureInfo.InvariantCulture) + ";");
                }

                builder.AppendLine();
                builder.AppendLine("\t\tpublic static global::System.Span<" + elementTypeName + "> " + idSegment + "Array(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component)");
                builder.AppendLine("\t\t{");
                builder.AppendLine("\t\t\t" + poolName + " pool = " + componentName + ".Api.GetPoolForProperties(reg);");
                builder.AppendLine("\t\t\tref var buffer = ref pool." + arrayField.FieldName + "Ref(component);");
                builder.AppendLine("\t\t\treturn global::System.Runtime.InteropServices.MemoryMarshal.CreateSpan(ref buffer[0], " + idSegment + "Length);");
                builder.AppendLine("\t\t}");

                if (arrayField.ArrayValues.IsArray2D)
                {
                    builder.AppendLine();
                    builder.AppendLine("\t\tpublic static global::System.Span<" + elementTypeName + "> " + idSegment + "Row(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component, int row)");
                    builder.AppendLine("\t\t{");
                    builder.AppendLine("\t\t\tint start = row * " + idSegment + "Cols;");
                    builder.AppendLine("\t\t\treturn " + idSegment + "Array(reg, component).Slice(start, " + idSegment + "Cols);");
                    builder.AppendLine("\t\t}");

                    builder.AppendLine();
                    builder.AppendLine("\t\tpublic static ref " + elementTypeName + " " + idSegment + "At(global::Pooled.Runtime.IPoolRegistry reg, " + componentHandleName + " component, int row, int col)");
                    builder.AppendLine("\t\t{");
                    builder.AppendLine("\t\t\tint index = row * " + idSegment + "Cols + col;");
                    builder.AppendLine("\t\t\treturn ref " + idSegment + "Array(reg, component)[index];");
                    builder.AppendLine("\t\t}");
                }
            }
        }

        private static bool TryResolveArrayElementType(PropertyComponentModel model, string fieldName, out string elementTypeName)
        {
            for (int i = 0; i < model.Properties.Count; i++)
            {
                var leaf = model.Properties[i];
                var segments = leaf.Segments;
                if (segments.Length < 2)
                {
                    continue;
                }
                if (segments[0].Name != fieldName)
                {
                    continue;
                }
                if (!segments[1].IsArrayElement)
                {
                    continue;
                }

                elementTypeName = segments[1].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return true;
            }

            elementTypeName = string.Empty;
            return false;
        }

        private static void AppendRefAccessor(
            StringBuilder builder,
            PropertyComponentModel model,
            PropertyLeafModel leaf,
            string componentName,
            string poolName,
            string componentTypeName,
            string componentHandleName)
        {
            builder.AppendLine("\t\t\t" + poolName + " pool = " + componentName + ".Api.GetPoolForProperties(reg);");

            if (model.IsSoA)
            {
                AppendSoARefChain(builder, leaf, poolName, componentHandleName);
                return;
            }

            builder.AppendLine("\t\t\tref " + componentTypeName + " componentRef = ref pool.GetRef(component);");
            AppendAoSRefChain(builder, leaf);
        }

        private static void AppendSoARefChain(StringBuilder builder, PropertyLeafModel leaf, string poolName, string componentHandleName)
        {
            var segments = leaf.Segments;
            if (segments.Length == 1)
            {
                builder.AppendLine("\t\t\treturn ref pool." + segments[0].Name + "Ref(component);");
                return;
            }

            var usedNames = new HashSet<string>();
            string rootVarName = GetUniqueLocalName(NameFormatter.ToCamelCase(segments[0].Name), usedNames);
            string rootTypeName = segments[0].Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            builder.AppendLine("\t\t\tref " + rootTypeName + " " + rootVarName + " = ref pool." + segments[0].Name + "Ref(component);");

            string previousVarName = rootVarName;
            for (int index = 1; index < segments.Length - 1; index++)
            {
                var segment = segments[index];
                string localTypeName = segment.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (segment.IsArrayElement)
                {
                    string localName = GetUniqueLocalName("elem" + segment.FixedIndex.ToString(CultureInfo.InvariantCulture), usedNames);
                    builder.AppendLine("\t\t\tref " + localTypeName + " " + localName + " = ref " + previousVarName + "[" + segment.FixedIndex.ToString(CultureInfo.InvariantCulture) + "];");
                    previousVarName = localName;
                }
                else
                {
                    string localName = GetUniqueLocalName(NameFormatter.ToCamelCase(segment.Name), usedNames);
                    builder.AppendLine("\t\t\tref " + localTypeName + " " + localName + " = ref " + previousVarName + "." + segment.Name + ";");
                    previousVarName = localName;
                }
            }

            var last = segments[segments.Length - 1];
            if (last.IsArrayElement)
            {
                builder.AppendLine("\t\t\treturn ref " + previousVarName + "[" + last.FixedIndex.ToString(CultureInfo.InvariantCulture) + "];");
            }
            else
            {
                builder.AppendLine("\t\t\treturn ref " + previousVarName + "." + last.Name + ";");
            }
        }

        private static void AppendAoSRefChain(StringBuilder builder, PropertyLeafModel leaf)
        {
            var segments = leaf.Segments;
            var usedNames = new HashSet<string>();

            string previousVarName = "componentRef";
            if (segments.Length == 1)
            {
                builder.AppendLine("\t\t\treturn ref componentRef." + segments[0].Name + ";");
                return;
            }

            for (int index = 0; index < segments.Length - 1; index++)
            {
                var segment = segments[index];
                string localTypeName = segment.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (segment.IsArrayElement)
                {
                    string localName = GetUniqueLocalName("elem" + segment.FixedIndex.ToString(CultureInfo.InvariantCulture), usedNames);
                    builder.AppendLine("\t\t\tref " + localTypeName + " " + localName + " = ref " + previousVarName + "[" + segment.FixedIndex.ToString(CultureInfo.InvariantCulture) + "];");
                    previousVarName = localName;
                }
                else
                {
                    string localName = GetUniqueLocalName(NameFormatter.ToCamelCase(segment.Name), usedNames);
                    builder.AppendLine("\t\t\tref " + localTypeName + " " + localName + " = ref " + previousVarName + "." + segment.Name + ";");
                    previousVarName = localName;
                }
            }

            var last = segments[segments.Length - 1];
            if (last.IsArrayElement)
            {
                builder.AppendLine("\t\t\treturn ref " + previousVarName + "[" + last.FixedIndex.ToString(CultureInfo.InvariantCulture) + "];");
            }
            else
            {
                builder.AppendLine("\t\t\treturn ref " + previousVarName + "." + last.Name + ";");
            }
        }

        private static string GetUniqueLocalName(string baseName, HashSet<string> usedNames)
        {
            string name = baseName;
            int suffix = 1;
            while (!usedNames.Add(name))
            {
                name = baseName + suffix.ToString(CultureInfo.InvariantCulture);
                suffix++;
            }
            return name;
        }

        private static string EscapeString(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return string.Empty;
            }

            return value.Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\r", "\\r")
                .Replace("\n", "\\n");
        }

        private static string FormatFloat(float value)
        {
            if (float.IsNaN(value))
            {
                return "float.NaN";
            }
            if (float.IsPositiveInfinity(value))
            {
                return "float.PositiveInfinity";
            }
            if (float.IsNegativeInfinity(value))
            {
                return "float.NegativeInfinity";
            }
            return value.ToString("R", CultureInfo.InvariantCulture) + "f";
        }
    }
}
