// SPDX-License-Identifier: MIT
#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace Property.Generator
{
    internal static class DispatcherRenderer
    {
        public static string Render(IReadOnlyDictionary<INamedTypeSymbol, PropertyComponentModel> componentModels)
        {
            var builder = new StringBuilder(16_384);
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine("#nullable enable");
            builder.AppendLine("namespace Property.Runtime");
            builder.AppendLine("{");
            builder.AppendLine("\tpublic static class PropertyDispatcher");
            builder.AppendLine("\t{");

            var componentList = new List<PropertyComponentModel>(componentModels.Values);
            componentList.Sort((left, right) =>
            {
                string leftName = left.ComponentSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                string rightName = right.ComponentSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return string.CompareOrdinal(leftName, rightName);
            });

            builder.AppendLine("\t\tpublic static void RegisterAll()");
            builder.AppendLine("\t\t{");
            foreach (var componentModel in componentList)
            {
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t" + componentPropertiesName + ".RegisterNames();");
            }
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static int GetPropertyCount(global::Property.Runtime.AnyComponentHandle component)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (component.Kind)");
            builder.AppendLine("\t\t\t{");
            foreach (var componentModel in componentList)
            {
                string componentTypeName = GetComponentTypeName(componentModel.ComponentSymbol);
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t\tcase " + componentTypeName + ".Api.PoolIdConst:");
                builder.AppendLine("\t\t\t\t\treturn " + componentPropertiesName + ".PropertyCount;");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\treturn 0;");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static bool TryGetInfo(global::Property.Runtime.AnyComponentHandle component, int index, out global::Property.Runtime.PropertyInfo info)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (component.Kind)");
            builder.AppendLine("\t\t\t{");
            foreach (var componentModel in componentList)
            {
                string componentTypeName = GetComponentTypeName(componentModel.ComponentSymbol);
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t\tcase " + componentTypeName + ".Api.PoolIdConst:");
                builder.AppendLine("\t\t\t\t\treturn " + componentPropertiesName + ".TryGetInfoByIndex(index, out info);");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tinfo = default;");
            builder.AppendLine("\t\t\t\t\treturn false;");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static global::Property.Runtime.PropertySlot GetSlot(global::Property.Runtime.AnyComponentHandle component, int index)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (component.Kind)");
            builder.AppendLine("\t\t\t{");
            foreach (var componentModel in componentList)
            {
                string componentTypeName = GetComponentTypeName(componentModel.ComponentSymbol);
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t\tcase " + componentTypeName + ".Api.PoolIdConst:");
                builder.AppendLine("\t\t\t\t\treturn " + componentPropertiesName + ".GetSlotByIndex(component, index);");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid component kind.\");");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            // Emit a stable set of Read*/Write* APIs so downstream code can depend on them
            // even if a particular kind is not currently present in any component model.
            for (int kindIndex = 0; kindIndex < StableKinds.Length; kindIndex++)
            {
                RenderReadWrite(builder, componentList, StableKinds[kindIndex]);
            }

            builder.AppendLine("\t}");
            builder.AppendLine("}");
            return builder.ToString();
        }

        private static void RenderReadWrite(StringBuilder builder, List<PropertyComponentModel> componentList, PropertyKind kind)
        {
            string kindName = kind.ToString();
            string typeName = PropertyTypeMap.GetTypeName(kind);

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static " + typeName + " Read" + kindName + "(global::Pooled.Runtime.IPoolRegistry reg, global::Property.Runtime.PropertySlot slot)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (slot.Component.Kind)");
            builder.AppendLine("\t\t\t{");
            foreach (var componentModel in componentList)
            {
                if (!ComponentHasKind(componentModel, kind))
                {
                    continue;
                }

                string componentTypeName = GetComponentTypeName(componentModel.ComponentSymbol);
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t\tcase " + componentTypeName + ".Api.PoolIdConst:");
                builder.AppendLine("\t\t\t\t\treturn " + componentPropertiesName + ".Get" + kindName + "ByIndex(reg, " + componentPropertiesName + ".ToTypedHandle(slot.Component), slot.PropertyIndex);");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid component kind.\");");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");

            builder.AppendLine();
            builder.AppendLine("\t\tpublic static void Write" + kindName + "(global::Pooled.Runtime.IPoolRegistry reg, global::Property.Runtime.PropertySlot slot, " + typeName + " value)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tswitch (slot.Component.Kind)");
            builder.AppendLine("\t\t\t{");
            foreach (var componentModel in componentList)
            {
                if (!ComponentHasKind(componentModel, kind))
                {
                    continue;
                }

                string componentTypeName = GetComponentTypeName(componentModel.ComponentSymbol);
                string componentPropertiesName = GetComponentPropertiesName(componentModel.ComponentSymbol);
                builder.AppendLine("\t\t\t\tcase " + componentTypeName + ".Api.PoolIdConst:");
                builder.AppendLine("\t\t\t\t\t" + componentPropertiesName + ".Set" + kindName + "ByIndex(reg, " + componentPropertiesName + ".ToTypedHandle(slot.Component), slot.PropertyIndex, value);");
                builder.AppendLine("\t\t\t\t\treturn;");
            }
            builder.AppendLine("\t\t\t\tdefault:");
            builder.AppendLine("\t\t\t\t\tthrow new global::System.InvalidOperationException(\"Invalid component kind.\");");
            builder.AppendLine("\t\t\t}");
            builder.AppendLine("\t\t}");
        }

        private static readonly PropertyKind[] StableKinds =
        [
            PropertyKind.Float,
            PropertyKind.Int,
            PropertyKind.Bool,
            PropertyKind.Vec2,
            PropertyKind.Vec3,
            PropertyKind.Vec4,
            PropertyKind.Color32,
            PropertyKind.StringHandle,
            PropertyKind.Fixed64,
            PropertyKind.Fixed64Vec2,
            PropertyKind.Fixed64Vec3,
        ];

        private static bool ComponentHasKind(PropertyComponentModel model, PropertyKind kind)
        {
            foreach (var leaf in model.Properties)
            {
                if (leaf.Kind == kind)
                {
                    return true;
                }
            }
            return false;
        }

        private static string GetComponentTypeName(INamedTypeSymbol componentSymbol)
        {
            return componentSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        private static string GetComponentPropertiesName(INamedTypeSymbol componentSymbol)
        {
            string namespaceName = componentSymbol.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::";
            string prefix = namespaceName == "global::" ? "global::" : namespaceName + ".";
            return prefix + componentSymbol.Name + "Properties";
        }
    }
}
