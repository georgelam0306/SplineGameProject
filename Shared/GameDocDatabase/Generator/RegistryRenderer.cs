using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace GameDocDatabase.Generator;

/// <summary>
/// Generates GameDataId constant classes from JSON data files.
/// Example: UnitTypeIds.Soldier, ZombieTypeIds.Walker
/// </summary>
internal static class RegistryRenderer
{
    /// <summary>
    /// Renders a constants class for a single table.
    /// </summary>
    public static string Render(TableSchemaModel model, List<(int Id, string Name)> entries)
    {
        var sb = new StringBuilder(2048);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using GameDocDatabase;");
        sb.AppendLine();
        sb.AppendLine($"namespace {model.Namespace};");
        sb.AppendLine();

        // Generate class name from type name (e.g., UnitTypeData -> UnitTypeIds)
        var className = model.TypeName.EndsWith("Data")
            ? model.TypeName.Substring(0, model.TypeName.Length - 4) + "Ids"
            : model.TypeName + "Ids";

        // Generate enum name (e.g., UnitTypeData -> UnitTypeId)
        var enumName = model.TypeName.EndsWith("Data")
            ? model.TypeName.Substring(0, model.TypeName.Length - 4) + "Id"
            : model.TypeName + "Id";

        // Generate enum type
        sb.AppendLine($"/// <summary>Enum for {model.TypeName} entry IDs. Use with FindById.</summary>");
        sb.AppendLine($"public enum {enumName} : int");
        sb.AppendLine("{");
        foreach (var (id, name) in entries.OrderBy(e => e.Id))
        {
            var safeName = ToValidIdentifier(name);
            sb.AppendLine($"    {safeName} = {id},");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine($"/// <summary>Compile-time constants for {model.TypeName} entries.</summary>");
        sb.AppendLine($"public static class {className}");
        sb.AppendLine("{");

        // Generate constants
        foreach (var (id, name) in entries.OrderBy(e => e.Id))
        {
            var safeName = ToValidIdentifier(name);
            sb.AppendLine($"    /// <summary>{model.TypeName} entry: {name} (Id={id})</summary>");
            sb.AppendLine($"    public static readonly GameDataId {safeName} = new({id});");
        }

        sb.AppendLine();

        // Generate lookup arrays for name-to-id conversion
        sb.AppendLine("    // Sorted names for binary search lookup");
        sb.AppendLine("    private static readonly string[] _sortedNames = new[]");
        sb.AppendLine("    {");
        foreach (var (_, name) in entries.OrderBy(e => e.Name))
        {
            sb.AppendLine($"        \"{name}\",");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        sb.AppendLine("    private static readonly int[] _sortedIds = new[]");
        sb.AppendLine("    {");
        foreach (var (id, _) in entries.OrderBy(e => e.Name))
        {
            sb.AppendLine($"        {id},");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Generate TryGetId method
        sb.AppendLine("    /// <summary>Look up GameDataId by name using binary search. O(log n).</summary>");
        sb.AppendLine("    public static bool TryGetId(string name, out GameDataId id)");
        sb.AppendLine("    {");
        sb.AppendLine("        int lo = 0, hi = _sortedNames.Length - 1;");
        sb.AppendLine("        while (lo <= hi)");
        sb.AppendLine("        {");
        sb.AppendLine("            int mid = lo + ((hi - lo) >> 1);");
        sb.AppendLine("            int cmp = string.CompareOrdinal(_sortedNames[mid], name);");
        sb.AppendLine("            if (cmp == 0)");
        sb.AppendLine("            {");
        sb.AppendLine("                id = new GameDataId(_sortedIds[mid]);");
        sb.AppendLine("                return true;");
        sb.AppendLine("            }");
        sb.AppendLine("            if (cmp < 0)");
        sb.AppendLine("                lo = mid + 1;");
        sb.AppendLine("            else");
        sb.AppendLine("                hi = mid - 1;");
        sb.AppendLine("        }");
        sb.AppendLine("        id = GameDataId.Invalid;");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate GetName method
        sb.AppendLine("    /// <summary>Get the name for a GameDataId. Returns null if not found.</summary>");
        sb.AppendLine("    public static string? GetName(GameDataId id)");
        sb.AppendLine("    {");
        sb.AppendLine("        int value = id.Value;");
        sb.Append("        return value switch\n        {\n");
        foreach (var (id2, name) in entries.OrderBy(e => e.Id))
        {
            sb.AppendLine($"            {id2} => \"{name}\",");
        }
        sb.AppendLine("            _ => null,");
        sb.AppendLine("        };");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Converts a name to a valid C# identifier.
    /// </summary>
    private static string ToValidIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
            return "_Empty";

        // Replace invalid characters with underscores
        var result = Regex.Replace(name, @"[^a-zA-Z0-9_]", "_");

        // Ensure it doesn't start with a digit
        if (char.IsDigit(result[0]))
            result = "_" + result;

        // Handle C# keywords
        if (IsCSharpKeyword(result))
            result = "@" + result;

        return result;
    }

    private static bool IsCSharpKeyword(string name)
    {
        return name switch
        {
            "abstract" or "as" or "base" or "bool" or "break" or "byte" or "case" or
            "catch" or "char" or "checked" or "class" or "const" or "continue" or
            "decimal" or "default" or "delegate" or "do" or "double" or "else" or
            "enum" or "event" or "explicit" or "extern" or "false" or "finally" or
            "fixed" or "float" or "for" or "foreach" or "goto" or "if" or "implicit" or
            "in" or "int" or "interface" or "internal" or "is" or "lock" or "long" or
            "namespace" or "new" or "null" or "object" or "operator" or "out" or
            "override" or "params" or "private" or "protected" or "public" or "readonly" or
            "ref" or "return" or "sbyte" or "sealed" or "short" or "sizeof" or
            "stackalloc" or "static" or "string" or "struct" or "switch" or "this" or
            "throw" or "true" or "try" or "typeof" or "uint" or "ulong" or "unchecked" or
            "unsafe" or "ushort" or "using" or "virtual" or "void" or "volatile" or "while"
            => true,
            _ => false
        };
    }
}
