using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace GameDocDatabase.Generator;

/// <summary>
/// Generates GameDataBinaryLoader and GameDocDbMapped for loading .bin files.
/// </summary>
internal static class BinaryLoaderRenderer
{
    public static string Render(List<TableSchemaModel> tables, string targetNamespace)
    {
        var sb = new StringBuilder(16384);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.IO;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using GameDocDatabase;");
        sb.AppendLine("using GameDocDatabase.Runtime;");
        sb.AppendLine();
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();

        // Generate the existing GameDataBinaryLoader (copies to arrays)
        RenderBinaryLoader(sb, tables);
        sb.AppendLine();

        // Generate the new GameDocDbMapped (zero-copy mmap wrapper)
        RenderMappedDb(sb, tables);

        return sb.ToString();
    }

    private static void RenderBinaryLoader(StringBuilder sb, List<TableSchemaModel> tables)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Loads GameData.bin and creates GameDocDb instance (copies data to managed arrays).");
        sb.AppendLine("/// For zero-copy access, use GameDocDbMapped instead.");
        sb.AppendLine("/// Auto-generated - do not modify.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class GameDataBinaryLoader");
        sb.AppendLine("{");

        // Load method that returns GameDocDb
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Loads binary data file and creates GameDocDb (copies to managed arrays).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static GameDocDb Load(string binPath)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var loader = BinaryLoader.Load(binPath);");
        sb.AppendLine();

        foreach (var table in tables)
        {
            sb.AppendLine($"        var {ToCamelCase(table.TableName)} = loader.GetRecords<{table.TypeName}>(\"{table.TableName}\").ToArray();");
        }

        sb.AppendLine();
        sb.AppendLine("        return new GameDocDb(");

        for (int i = 0; i < tables.Count; i++)
        {
            var table = tables[i];
            var comma = i < tables.Count - 1 ? "," : "";
            sb.AppendLine($"            new {table.TypeName}Table({ToCamelCase(table.TableName)}){comma}");
        }

        sb.AppendLine("        );");
        sb.AppendLine("    }");
        sb.AppendLine();

        // LoadMapped method that returns GameDocDbMapped
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Loads binary data file with zero-copy memory-mapped access.");
        sb.AppendLine("    /// The returned object must be disposed when done.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static GameDocDbMapped LoadMapped(string binPath)");
        sb.AppendLine("    {");
        sb.AppendLine("        return new GameDocDbMapped(binPath);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // LoadWithChecksum method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Loads binary data and returns checksum for network sync verification.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static (GameDocDb Db, byte[] Checksum) LoadWithChecksum(string binPath)");
        sb.AppendLine("    {");
        sb.AppendLine("        var checksum = System.Security.Cryptography.SHA256.HashData(File.ReadAllBytes(binPath));");
        sb.AppendLine("        var db = Load(binPath);");
        sb.AppendLine("        return (db, checksum);");
        sb.AppendLine("    }");

        sb.AppendLine("}");
    }

    private static void RenderMappedDb(StringBuilder sb, List<TableSchemaModel> tables)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Zero-copy memory-mapped game database. Keeps the binary file mapped in memory");
        sb.AppendLine("/// and provides direct access to records without copying to managed heap.");
        sb.AppendLine("/// Must be disposed when done to release the memory mapping.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public sealed class GameDocDbMapped : IDisposable");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly BinaryLoader _loader;");
        sb.AppendLine("    private bool _disposed;");
        sb.AppendLine();

        // Table accessor fields
        foreach (var table in tables)
        {
            sb.AppendLine($"    private {table.TypeName}MappedTable? _{ToCamelCase(table.TableName)};");
        }
        sb.AppendLine();

        // Constructor
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Creates a new memory-mapped database from the specified binary file.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public GameDocDbMapped(string binPath)");
        sb.AppendLine("    {");
        sb.AppendLine("        _loader = BinaryLoader.Load(binPath);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Table accessor properties (lazy init)
        foreach (var table in tables)
        {
            var fieldName = $"_{ToCamelCase(table.TableName)}";
            sb.AppendLine($"    /// <summary>Access {table.TypeName} records.</summary>");
            sb.AppendLine($"    public {table.TypeName}MappedTable {table.TypeName} => {fieldName} ??= new {table.TypeName}MappedTable(_loader);");
            sb.AppendLine();
        }

        // Dispose
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Releases the memory-mapped file.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public void Dispose()");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_disposed) return;");
        sb.AppendLine("        _disposed = true;");
        sb.AppendLine("        _loader.Dispose();");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        // Generate MappedTable struct for each table
        foreach (var table in tables)
        {
            RenderMappedTable(sb, table);
            sb.AppendLine();
        }
    }

    private static void RenderMappedTable(StringBuilder sb, TableSchemaModel table)
    {
        var typeName = table.TypeName;
        var tableName = table.TableName;
        var primaryKey = table.PrimaryKey;

        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Zero-copy accessor for {typeName} records.");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"public sealed class {typeName}MappedTable");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly TableAccessor<{typeName}> _accessor;");
        sb.AppendLine("    private readonly BinaryLoader _loader;");

        // Secondary index fields (lazy-built)
        foreach (var sk in table.SecondaryKeys)
        {
            if (sk.IsNonUnique)
            {
                sb.AppendLine($"    private readonly Lazy<Dictionary<{sk.Field.TypeName}, List<int>>> _indexBy{sk.Field.Name};");
            }
            else
            {
                sb.AppendLine($"    private readonly Lazy<Dictionary<{sk.Field.TypeName}, int>> _indexBy{sk.Field.Name};");
            }
        }
        sb.AppendLine();

        // Constructor - cache TableAccessor for zero-overhead access
        sb.AppendLine($"    internal {typeName}MappedTable(BinaryLoader loader)");
        sb.AppendLine("    {");
        sb.AppendLine("        _loader = loader;");
        sb.AppendLine($"        _accessor = loader.GetTableAccessor<{typeName}>(\"{tableName}\");");

        // Initialize lazy secondary indexes
        foreach (var sk in table.SecondaryKeys)
        {
            sb.AppendLine($"        _indexBy{sk.Field.Name} = new Lazy<Dictionary<{sk.Field.TypeName}, {(sk.IsNonUnique ? "List<int>" : "int")}>>(() => Build{sk.Field.Name}Index());");
        }

        sb.AppendLine("    }");
        sb.AppendLine();

        // Count property
        sb.AppendLine("    /// <summary>Number of records in this table.</summary>");
        sb.AppendLine($"    public int Count => _accessor.Count;");
        sb.AppendLine();

        // All property - returns span from cached accessor
        sb.AppendLine("    /// <summary>All records as a read-only span (zero-copy).</summary>");
        sb.AppendLine($"    public ReadOnlySpan<{typeName}> All => _accessor.All;");
        sb.AppendLine();

        // Primary key lookups - generate overloads matching TableRenderer
        if (primaryKey != null)
        {
            var pk = primaryKey;
            var pkParamName = ToCamelCase(pk.Name);

            // Always generate int overload
            RenderMappedFindByPrimaryKey(sb, typeName, pk.Name, "int", pkParamName);
            RenderMappedTryFindByPrimaryKey(sb, typeName, pk.Name, "int", pkParamName);

            // Generate GameDataId overload
            RenderMappedFindByPrimaryKey(sb, typeName, pk.Name, "GameDataId", pkParamName);
            RenderMappedTryFindByPrimaryKey(sb, typeName, pk.Name, "GameDataId", pkParamName);

            // Generate enum overload if convention-based enum type exists
            var enumType = GetConventionalEnumType(typeName);
            if (enumType != null)
            {
                RenderMappedFindByPrimaryKey(sb, typeName, pk.Name, enumType, pkParamName);
                RenderMappedTryFindByPrimaryKey(sb, typeName, pk.Name, enumType, pkParamName);
            }
        }

        // GetAtIndex
        sb.AppendLine("    /// <summary>Gets a record by index (not by ID).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public ref readonly {typeName} GetAtIndex(int index) => ref _accessor.GetAtIndex(index);");
        sb.AppendLine();

        // Secondary key lookups
        foreach (var sk in table.SecondaryKeys)
        {
            if (sk.IsNonUnique)
            {
                // Non-unique: returns multiple results
                sb.AppendLine($"    /// <summary>Finds all records with the specified {sk.Field.Name}.</summary>");
                sb.AppendLine($"    public {typeName}MappedRange FindBy{sk.Field.Name}({sk.Field.TypeName} key)");
                sb.AppendLine("    {");
                sb.AppendLine($"        if (_indexBy{sk.Field.Name}.Value.TryGetValue(key, out var indices))");
                sb.AppendLine($"            return new {typeName}MappedRange(_loader, indices);");
                sb.AppendLine($"        return new {typeName}MappedRange(_loader, null);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
            else
            {
                // Unique: returns single result
                sb.AppendLine($"    /// <summary>Finds a record by unique key {sk.Field.Name}.</summary>");
                sb.AppendLine($"    public ref readonly {typeName} FindBy{sk.Field.Name}({sk.Field.TypeName} key)");
                sb.AppendLine("    {");
                sb.AppendLine($"        var index = _indexBy{sk.Field.Name}.Value[key];");
                sb.AppendLine($"        return ref All[index];");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
        }

        // Build secondary index methods
        foreach (var sk in table.SecondaryKeys)
        {
            if (sk.IsNonUnique)
            {
                sb.AppendLine($"    private Dictionary<{sk.Field.TypeName}, List<int>> Build{sk.Field.Name}Index()");
                sb.AppendLine("    {");
                sb.AppendLine($"        var dict = new Dictionary<{sk.Field.TypeName}, List<int>>();");
                sb.AppendLine("        var all = All;");
                sb.AppendLine("        for (int i = 0; i < all.Length; i++)");
                sb.AppendLine("        {");
                sb.AppendLine($"            var key = all[i].{sk.Field.Name};");
                sb.AppendLine("            if (!dict.TryGetValue(key, out var list))");
                sb.AppendLine("            {");
                sb.AppendLine("                list = new List<int>();");
                sb.AppendLine("                dict[key] = list;");
                sb.AppendLine("            }");
                sb.AppendLine("            list.Add(i);");
                sb.AppendLine("        }");
                sb.AppendLine("        return dict;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
            else
            {
                sb.AppendLine($"    private Dictionary<{sk.Field.TypeName}, int> Build{sk.Field.Name}Index()");
                sb.AppendLine("    {");
                sb.AppendLine($"        var dict = new Dictionary<{sk.Field.TypeName}, int>();");
                sb.AppendLine("        var all = All;");
                sb.AppendLine("        for (int i = 0; i < all.Length; i++)");
                sb.AppendLine($"            dict[all[i].{sk.Field.Name}] = i;");
                sb.AppendLine("        return dict;");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");

        // Generate MappedRange struct for non-unique secondary key results
        var hasNonUniqueKeys = table.SecondaryKeys.Any(sk => sk.IsNonUnique);
        if (hasNonUniqueKeys)
        {
            sb.AppendLine();
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Range of {typeName} records matching a secondary key query.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"public readonly struct {typeName}MappedRange");
            sb.AppendLine("{");
            sb.AppendLine("    private readonly BinaryLoader _loader;");
            sb.AppendLine("    private readonly List<int>? _indices;");
            sb.AppendLine($"    private readonly string _tableName;");
            sb.AppendLine();
            sb.AppendLine($"    internal {typeName}MappedRange(BinaryLoader loader, List<int>? indices)");
            sb.AppendLine("    {");
            sb.AppendLine("        _loader = loader;");
            sb.AppendLine("        _indices = indices;");
            sb.AppendLine($"        _tableName = \"{tableName}\";");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>Number of matching records.</summary>");
            sb.AppendLine("    public int Count => _indices?.Count ?? 0;");
            sb.AppendLine();
            sb.AppendLine("    /// <summary>Gets an enumerator for the matching records.</summary>");
            sb.AppendLine($"    public Enumerator GetEnumerator() => new Enumerator(_loader, _indices, _tableName);");
            sb.AppendLine();
            sb.AppendLine($"    public ref struct Enumerator");
            sb.AppendLine("    {");
            sb.AppendLine($"        private readonly ReadOnlySpan<{typeName}> _all;");
            sb.AppendLine("        private readonly List<int>? _indices;");
            sb.AppendLine("        private int _position;");
            sb.AppendLine();
            sb.AppendLine($"        internal Enumerator(BinaryLoader loader, List<int>? indices, string tableName)");
            sb.AppendLine("        {");
            sb.AppendLine($"            _all = loader.GetRecords<{typeName}>(tableName);");
            sb.AppendLine("            _indices = indices;");
            sb.AppendLine("            _position = -1;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public ref readonly {typeName} Current => ref _all[_indices![_position]];");
            sb.AppendLine();
            sb.AppendLine("        public bool MoveNext()");
            sb.AppendLine("        {");
            sb.AppendLine("            if (_indices == null) return false;");
            sb.AppendLine("            _position++;");
            sb.AppendLine("            return _position < _indices.Count;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
        }
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    /// <summary>
    /// Gets conventional enum type name from data type name.
    /// e.g., "ZombieTypeData" -> "ZombieTypeId"
    /// </summary>
    private static string? GetConventionalEnumType(string typeName)
    {
        if (typeName.EndsWith("Data"))
        {
            return typeName.Substring(0, typeName.Length - 4) + "Id";
        }
        return null;
    }

    private static void RenderMappedFindByPrimaryKey(StringBuilder sb, string typeName, string pkName, string paramType, string paramName)
    {
        sb.AppendLine($"    /// <summary>O(1) lookup by {pkName} (zero-copy, no dictionary overhead).</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public ref readonly {typeName} FindBy{pkName}({paramType} {paramName})");
        sb.AppendLine("    {");
        sb.AppendLine($"        return ref _accessor.FindById({GetKeyValueExpression(paramType, paramName)});");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void RenderMappedTryFindByPrimaryKey(StringBuilder sb, string typeName, string pkName, string paramType, string paramName)
    {
        sb.AppendLine($"    /// <summary>O(1) lookup by {pkName}, returns false if not found.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public bool TryFindBy{pkName}({paramType} {paramName}, out {typeName} result)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return _accessor.TryFindById({GetKeyValueExpression(paramType, paramName)}, out result);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GetKeyValueExpression(string paramType, string paramName)
    {
        if (paramType == "int")
            return paramName;
        if (paramType == "GameDataId")
            return $"{paramName}.Value";
        // Enum type - cast to int
        return $"(int){paramName}";
    }
}
