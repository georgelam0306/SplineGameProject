// SPDX-License-Identifier: MIT
#nullable enable
using DerpLib.DI.Generator.Model;
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Text;

namespace DerpLib.DI.Generator.Emit
{
    /// <summary>
    /// Emits the generated composition class.
    /// </summary>
    internal static class CompositionEmitter
    {
        /// <summary>
        /// Emits the full generated source for a composition.
        /// </summary>
        public static string Emit(CompositionModel composition, List<Diagnostic> diagnostics)
        {
            var sb = new StringBuilder(32_768);

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");

            // Emit using directives from source file
            if (composition.SourceUsings.Count > 0)
            {
                sb.AppendLine();
                foreach (var usingDirective in composition.SourceUsings)
                {
                    sb.AppendLine(usingDirective);
                }
            }

            sb.AppendLine();

            if (composition.Namespace is not null)
            {
                sb.AppendLine($"namespace {composition.Namespace};");
                sb.AppendLine();
            }

            var indent = "";
            EmitClass(sb, composition, indent, diagnostics);

            return sb.ToString();
        }

        private static void EmitClass(StringBuilder sb, CompositionModel composition, string indent, List<Diagnostic> diagnostics)
        {
            sb.AppendLine($"{indent}partial class {composition.ClassName} : global::System.IDisposable");
            sb.AppendLine($"{indent}{{");

            var memberIndent = indent + "    ";

            // Parent reference (for child compositions)
            if (composition.Parent is not null)
            {
                EmitSection(sb, memberIndent, "Parent Reference");
                sb.AppendLine($"{memberIndent}private readonly {composition.Parent.FullTypeName} _parent;");
                sb.AppendLine();
            }

            // Arguments
            if (composition.Args.Count > 0)
            {
                EmitSection(sb, memberIndent, "Arguments");
                foreach (var arg in composition.Args)
                {
                    sb.AppendLine($"{memberIndent}private readonly {arg.FullTypeName} _arg_{arg.Name};");
                }
                sb.AppendLine();
            }

            // Singleton fields
            var singletonBindings = GetSingletonBindings(composition);
            var hasCollectionSingletons = HasSingletonCollectionItems(composition);
            if (singletonBindings.Count > 0 || composition.Scopes.Count > 0 || hasCollectionSingletons)
            {
                EmitSection(sb, memberIndent, "Singleton Fields");
                sb.AppendLine($"{memberIndent}private readonly global::System.Threading.Lock _lock = new();");

                foreach (var binding in singletonBindings)
                {
                    sb.AppendLine($"{memberIndent}private {binding.ServiceTypeName}? {binding.GetSingletonFieldName()};");
                }

                foreach (var collection in composition.CollectionBindings)
                {
                    if (collection.Lifetime == BindingLifetime.Singleton)
                    {
                        for (int i = 0; i < collection.Items.Count; i++)
                        {
                            sb.AppendLine($"{memberIndent}private {collection.ServiceTypeName}? {collection.GetItemSingletonFieldName(i)};");
                        }
                    }
                }

                foreach (var scope in composition.Scopes)
                {
                    sb.AppendLine($"{memberIndent}private {scope.GetFactoryTypeName()}? {scope.GetFactorySingletonFieldName()};");
                }
                sb.AppendLine();
            }

            // Disposal tracking
            EmitSection(sb, memberIndent, "Disposal Tracking");
            DisposalEmitter.EmitFields(sb, memberIndent);
            sb.AppendLine();

            // Constructor
            EmitSection(sb, memberIndent, "Constructor");
            EmitConstructor(sb, composition, memberIndent);
            sb.AppendLine();

            // Roots
            if (composition.Roots.Count > 0)
            {
                EmitSection(sb, memberIndent, "Roots");
                foreach (var root in composition.Roots)
                {
                    var resolved = composition.TryResolve(root.Type);
                    var resolverMethod = resolved?.GetResolverMethodName() ?? $"Resolve_{root.Type.Name}";
                    sb.AppendLine($"{memberIndent}public {root.FullTypeName} {root.Name} => {resolverMethod}();");
                }
                sb.AppendLine();
            }

            // Resolution methods for args
            if (composition.Args.Count > 0)
            {
                EmitSection(sb, memberIndent, "Resolution Methods - Arguments");
                foreach (var arg in composition.Args)
                {
                    ResolverEmitter.EmitArgResolver(sb, arg, memberIndent);
                }
                sb.AppendLine();
            }

            // Inherited forwarding methods (for child compositions)
            if (composition.Parent is not null)
            {
                var inherited = GetInheritedBindings(composition);
                if (inherited.Count > 0)
                {
                    EmitSection(sb, memberIndent, "Resolution Methods - Inherited");
                    foreach (var resolved in inherited)
                    {
                        ResolverEmitter.EmitInheritedResolver(sb, resolved, memberIndent);
                    }
                    sb.AppendLine();
                }
            }

            // Resolution methods for bindings
            if (composition.Bindings.Count > 0)
            {
                EmitSection(sb, memberIndent, "Resolution Methods - Bindings");
                foreach (var binding in composition.Bindings)
                {
                    ResolverEmitter.EmitBindingResolver(sb, binding, composition, memberIndent, diagnostics);
                    sb.AppendLine();
                }
            }

            // Collection binding resolvers
            if (composition.CollectionBindings.Count > 0)
            {
                EmitSection(sb, memberIndent, "Resolution Methods - Collection Bindings");
                foreach (var collection in composition.CollectionBindings)
                {
                    ResolverEmitter.EmitCollectionResolvers(sb, collection, composition, memberIndent, diagnostics);
                    sb.AppendLine();
                }
            }

            // Scope factory resolvers
            if (composition.Scopes.Count > 0)
            {
                EmitSection(sb, memberIndent, "Scope Factory Resolution");
                foreach (var scope in composition.Scopes)
                {
                    ResolverEmitter.EmitFactoryResolver(sb, scope, composition, memberIndent);
                    sb.AppendLine();
                }
            }

            // Disposal
            EmitSection(sb, memberIndent, "Disposal");
            DisposalEmitter.EmitTrackDisposable(sb, memberIndent);
            sb.AppendLine();
            DisposalEmitter.EmitDisposeMethod(sb, composition, memberIndent);
            sb.AppendLine();
            DisposalEmitter.EmitOnDisposeException(sb, memberIndent);

            // Factory class (for child compositions)
            if (composition.Parent is not null)
            {
                sb.AppendLine();
                FactoryEmitter.Emit(sb, composition, memberIndent);
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void EmitSection(StringBuilder sb, string indent, string title)
        {
            sb.AppendLine($"{indent}//==========================================================================");
            sb.AppendLine($"{indent}// {title}");
            sb.AppendLine($"{indent}//==========================================================================");
            sb.AppendLine();
        }

        private static void EmitConstructor(StringBuilder sb, CompositionModel composition, string indent)
        {
            var accessibility = composition.Parent is not null ? "internal" : "public";

            // Build parameter list
            var parameters = new List<string>();

            if (composition.Parent is not null)
            {
                parameters.Add($"{composition.Parent.FullTypeName} parent");
            }

            foreach (var arg in composition.Args)
            {
                parameters.Add($"{arg.FullTypeName} {arg.Name}");
            }

            sb.Append($"{indent}{accessibility} {composition.ClassName}(");

            if (parameters.Count <= 2)
            {
                sb.AppendLine($"{string.Join(", ", parameters)})");
            }
            else
            {
                sb.AppendLine();
                for (int i = 0; i < parameters.Count; i++)
                {
                    var comma = i < parameters.Count - 1 ? "," : ")";
                    sb.AppendLine($"{indent}    {parameters[i]}{comma}");
                }
            }

            sb.AppendLine($"{indent}{{");

            if (composition.Parent is not null)
            {
                sb.AppendLine($"{indent}    _parent = parent;");
            }

            foreach (var arg in composition.Args)
            {
                sb.AppendLine($"{indent}    _arg_{arg.Name} = {arg.Name};");
            }

            sb.AppendLine($"{indent}}}");
        }

        private static List<BindingModel> GetSingletonBindings(CompositionModel composition)
        {
            var result = new List<BindingModel>();
            foreach (var binding in composition.Bindings)
            {
                if (binding.Lifetime == BindingLifetime.Singleton)
                {
                    result.Add(binding);
                }
            }
            return result;
        }

        private static bool HasSingletonCollectionItems(CompositionModel composition)
        {
            foreach (var collection in composition.CollectionBindings)
            {
                if (collection.Lifetime == BindingLifetime.Singleton && collection.Items.Count > 0)
                    return true;
            }
            return false;
        }

        private static List<ResolvedBinding> GetInheritedBindings(CompositionModel composition)
        {
            var result = new List<ResolvedBinding>();
            var localKeys = new HashSet<string>();

            foreach (var binding in composition.Bindings)
            {
                localKeys.Add(binding.GetKey());
            }
            foreach (var arg in composition.Args)
            {
                localKeys.Add(arg.FullTypeName);
            }

            if (composition.Parent is not null)
            {
                foreach (var resolved in composition.Parent.GetAllBindings())
                {
                    if (!localKeys.Contains(resolved.GetKey()))
                    {
                        result.Add(resolved);
                    }
                }
            }

            return result;
        }
    }
}
