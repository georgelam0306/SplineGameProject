#nullable enable
using System.Text;

namespace SimTable.Generator
{
    internal static partial class TableRenderer
    {
        /// <summary>
        /// Renders box and radius query enumerables for chunked mode.
        /// Uses direct chunk lookup - O(query chunks) instead of O(active chunks).
        /// </summary>
        private static void RenderSpatialQueries(StringBuilder sb, string tableName)
        {
            // Box query
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Returns a zero-allocation enumerator for entities within the bounding box.");
            sb.AppendLine("        /// Usage: foreach (int slot in table.QueryBox(minX, maxX, minY, maxY)) { ... }");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public BoxQueryEnumerable QueryBox(Fixed64 minX, Fixed64 maxX, Fixed64 minY, Fixed64 maxY)");
            sb.AppendLine("        {");
            sb.AppendLine("            return new BoxQueryEnumerable(this, minX, maxX, minY, maxY);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Zero-allocation enumerable for box queries (supports foreach).</summary>");
            sb.AppendLine("        public readonly ref struct BoxQueryEnumerable");
            sb.AppendLine("        {");
            sb.AppendLine($"            private readonly {tableName} _table;");
            sb.AppendLine("            private readonly Fixed64 _minX, _maxX, _minY, _maxY;");
            sb.AppendLine();
            sb.AppendLine($"            public BoxQueryEnumerable({tableName} table, Fixed64 minX, Fixed64 maxX, Fixed64 minY, Fixed64 maxY)");
            sb.AppendLine("            {");
            sb.AppendLine("                _table = table;");
            sb.AppendLine("                _minX = minX;");
            sb.AppendLine("                _maxX = maxX;");
            sb.AppendLine("                _minY = minY;");
            sb.AppendLine("                _maxY = maxY;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            public BoxQueryEnumerator GetEnumerator() => new BoxQueryEnumerator(_table, _minX, _maxX, _minY, _maxY);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Zero-allocation enumerator for box queries using direct chunk lookup.</summary>");
            sb.AppendLine("        public ref struct BoxQueryEnumerator");
            sb.AppendLine("        {");
            sb.AppendLine($"            private readonly {tableName} _table;");
            sb.AppendLine("            private readonly Fixed64 _minX, _maxX, _minY, _maxY;");
            sb.AppendLine("            private readonly int _minChunkX, _maxChunkX, _minChunkY, _maxChunkY;");
            sb.AppendLine("            private readonly int _minWorldX, _maxWorldX, _minWorldY, _maxWorldY;");
            sb.AppendLine("            private int _chunkX, _chunkY;  // Current chunk coordinates (direct lookup)");
            sb.AppendLine("            private int _cellX, _cellY;   // Current cell within chunk");
            sb.AppendLine("            private int _minCellX, _maxCellX, _minCellY, _maxCellY;  // Cell range for current chunk");
            sb.AppendLine("            private int _poolIdx;         // Pool index for current chunk (-1 if none)");
            sb.AppendLine("            private int _entityIdx;       // Current entity index within cell");
            sb.AppendLine("            private int _entityEnd;       // End index for current cell");
            sb.AppendLine("            private int _current;         // Current slot value");
            sb.AppendLine();
            sb.AppendLine($"            public BoxQueryEnumerator({tableName} table, Fixed64 minX, Fixed64 maxX, Fixed64 minY, Fixed64 maxY)");
            sb.AppendLine("            {");
            sb.AppendLine("                _table = table;");
            sb.AppendLine("                _minX = minX;");
            sb.AppendLine("                _maxX = maxX;");
            sb.AppendLine("                _minY = minY;");
            sb.AppendLine("                _maxY = maxY;");
            sb.AppendLine();
            sb.AppendLine("                // Compute world bounding box");
            sb.AppendLine("                _minWorldX = minX.ToInt();");
            sb.AppendLine("                _maxWorldX = maxX.ToInt();");
            sb.AppendLine("                _minWorldY = minY.ToInt();");
            sb.AppendLine("                _maxWorldY = maxY.ToInt();");
            sb.AppendLine();
            sb.AppendLine("                // Compute chunk range from world coordinates");
            sb.AppendLine("                _minChunkX = _minWorldX >= 0 ? _minWorldX / ChunkSize : (_minWorldX - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _maxChunkX = _maxWorldX >= 0 ? _maxWorldX / ChunkSize : (_maxWorldX - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _minChunkY = _minWorldY >= 0 ? _minWorldY / ChunkSize : (_minWorldY - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _maxChunkY = _maxWorldY >= 0 ? _maxWorldY / ChunkSize : (_maxWorldY - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine();
            sb.AppendLine("                // Start before first chunk (will be incremented)");
            sb.AppendLine("                _chunkX = _minChunkX - 1;");
            sb.AppendLine("                _chunkY = _minChunkY;");
            sb.AppendLine("                _cellX = 0;");
            sb.AppendLine("                _cellY = 0;");
            sb.AppendLine("                _minCellX = 0;");
            sb.AppendLine("                _maxCellX = 0;");
            sb.AppendLine("                _minCellY = 0;");
            sb.AppendLine("                _maxCellY = 0;");
            sb.AppendLine("                _poolIdx = -1;");
            sb.AppendLine("                _entityIdx = 0;");
            sb.AppendLine("                _entityEnd = 0;");
            sb.AppendLine("                _current = -1;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            public int Current => _current;");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            public bool MoveNext()");
            sb.AppendLine("            {");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    // Try to get next entity from current cell");
            sb.AppendLine("                    while (_entityIdx < _entityEnd)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        int slot = _table._sortedOrder[_entityIdx++];");
            sb.AppendLine("                        var pos = _table.Position(slot);");
            sb.AppendLine("                        // Check if entity is within box bounds");
            sb.AppendLine("                        if (pos.X >= _minX && pos.X <= _maxX &&");
            sb.AppendLine("                            pos.Y >= _minY && pos.Y <= _maxY)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            _current = slot;");
            sb.AppendLine("                            return true;");
            sb.AppendLine("                        }");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Move to next cell or chunk");
            sb.AppendLine("                    if (!AdvanceToNextCell())");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _current = -1;");
            sb.AppendLine("                        return false;");
            sb.AppendLine("                    }");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            private bool AdvanceToNextCell()");
            sb.AppendLine("            {");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    // If we have a valid chunk, try next cell");
            sb.AppendLine("                    if (_poolIdx >= 0)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _cellX++;");
            sb.AppendLine("                        if (_cellX > _maxCellX)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            _cellX = _minCellX;");
            sb.AppendLine("                            _cellY++;");
            sb.AppendLine("                        }");
            sb.AppendLine("                        if (_cellY <= _maxCellY)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            ref var grid = ref _table._chunkGridPool[_poolIdx];");
            sb.AppendLine();
            sb.AppendLine("                            // Hierarchical coarse mask checks - skip empty regions");
            sb.AppendLine("                            if (HasChunkL2)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                int l2X = _cellX >> ChunkL2Shift;");
            sb.AppendLine("                                int l2Y = _cellY >> ChunkL2Shift;");
            sb.AppendLine("                                if ((grid.CoarseMaskL2 & (1UL << (l2Y * ChunkL2GridSize + l2X))) == 0)");
            sb.AppendLine("                                {");
            sb.AppendLine("                                    int nextL2X = (l2X + 1) << ChunkL2Shift;");
            sb.AppendLine("                                    _cellX = Math.Min(nextL2X, _maxCellX + 1) - 1;");
            sb.AppendLine("                                    continue;");
            sb.AppendLine("                                }");
            sb.AppendLine("                            }");
            sb.AppendLine("                            if (HasChunkL1)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                int l1X = _cellX >> ChunkL1Shift;");
            sb.AppendLine("                                int l1Y = _cellY >> ChunkL1Shift;");
            sb.AppendLine("                                if ((grid.CoarseMaskL1[l1Y] & (1UL << l1X)) == 0)");
            sb.AppendLine("                                {");
            sb.AppendLine("                                    int nextL1X = (l1X + 1) << ChunkL1Shift;");
            sb.AppendLine("                                    _cellX = Math.Min(nextL1X, _maxCellX + 1) - 1;");
            sb.AppendLine("                                    continue;");
            sb.AppendLine("                                }");
            sb.AppendLine("                            }");
            sb.AppendLine();
            sb.AppendLine("                            int cellIdx = _cellX + _cellY * GridSize;");
            sb.AppendLine("                            int count = grid.CellCount[cellIdx];");
            sb.AppendLine("                            if (count > 0)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                _entityIdx = grid.CellStart[cellIdx];");
            sb.AppendLine("                                _entityEnd = _entityIdx + count;");
            sb.AppendLine("                                return true;");
            sb.AppendLine("                            }");
            sb.AppendLine("                            continue; // Empty cell, try next");
            sb.AppendLine("                        }");
            sb.AppendLine("                        // Exhausted cells in this chunk");
            sb.AppendLine("                        _poolIdx = -1;");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Need to find next chunk (direct lookup)");
            sb.AppendLine("                    if (!AdvanceToNextChunk())");
            sb.AppendLine("                        return false;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            private bool AdvanceToNextChunk()");
            sb.AppendLine("            {");
            sb.AppendLine("                // Direct chunk lookup - O(query chunks) instead of O(active chunks)");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    _chunkX++;");
            sb.AppendLine("                    if (_chunkX > _maxChunkX)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _chunkX = _minChunkX;");
            sb.AppendLine("                        _chunkY++;");
            sb.AppendLine("                        if (_chunkY > _maxChunkY)");
            sb.AppendLine("                            return false;  // No more chunks in range");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Direct lookup of this chunk");
            sb.AppendLine("                    var key = new ChunkKey(_chunkX, _chunkY);");
            sb.AppendLine("                    if (!_table._chunkToPoolIndex.TryGetValue(key, out _poolIdx))");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _poolIdx = -1;");
            sb.AppendLine("                        continue;  // Chunk doesn't exist, try next");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Compute cell range within this chunk that overlaps query bbox");
            sb.AppendLine("                    int chunkWorldMinX = _chunkX * ChunkSize;");
            sb.AppendLine("                    int chunkWorldMinY = _chunkY * ChunkSize;");
            sb.AppendLine();
            sb.AppendLine("                    // Clamp query bbox to chunk bounds and convert to local cells");
            sb.AppendLine("                    int localMinX = Math.Max(0, _minWorldX - chunkWorldMinX);");
            sb.AppendLine("                    int localMaxX = Math.Min(ChunkSize - 1, _maxWorldX - chunkWorldMinX);");
            sb.AppendLine("                    int localMinY = Math.Max(0, _minWorldY - chunkWorldMinY);");
            sb.AppendLine("                    int localMaxY = Math.Min(ChunkSize - 1, _maxWorldY - chunkWorldMinY);");
            sb.AppendLine();
            sb.AppendLine("                    // Convert local coords to cell indices");
            sb.AppendLine("                    _minCellX = Math.Clamp(localMinX / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _maxCellX = Math.Clamp(localMaxX / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _minCellY = Math.Clamp(localMinY / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _maxCellY = Math.Clamp(localMaxY / CellSize, 0, GridSize - 1);");
            sb.AppendLine();
            sb.AppendLine("                    // Start before first cell (will be incremented)");
            sb.AppendLine("                    _cellX = _minCellX - 1;");
            sb.AppendLine("                    _cellY = _minCellY;");
            sb.AppendLine("                    return true;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Radius query
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Returns a zero-allocation enumerator for entities within a circular radius.");
            sb.AppendLine("        /// Pass the actual radius (not squared) - squared distance is computed internally.");
            sb.AppendLine("        /// Usage: foreach (int slot in table.QueryRadius(center, radius)) { ... }");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public RadiusQueryEnumerable QueryRadius(Fixed64Vec2 center, Fixed64 radius)");
            sb.AppendLine("        {");
            sb.AppendLine("            return new RadiusQueryEnumerable(this, center, radius);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Zero-allocation enumerable for radius queries (supports foreach).</summary>");
            sb.AppendLine("        public readonly ref struct RadiusQueryEnumerable");
            sb.AppendLine("        {");
            sb.AppendLine($"            private readonly {tableName} _table;");
            sb.AppendLine("            private readonly Fixed64Vec2 _center;");
            sb.AppendLine("            private readonly Fixed64 _radius;");
            sb.AppendLine();
            sb.AppendLine($"            public RadiusQueryEnumerable({tableName} table, Fixed64Vec2 center, Fixed64 radius)");
            sb.AppendLine("            {");
            sb.AppendLine("                _table = table;");
            sb.AppendLine("                _center = center;");
            sb.AppendLine("                _radius = radius;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            public RadiusQueryEnumerator GetEnumerator() => new RadiusQueryEnumerator(_table, _center, _radius);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        /// <summary>Zero-allocation enumerator for radius queries using direct chunk lookup.</summary>");
            sb.AppendLine("        public ref struct RadiusQueryEnumerator");
            sb.AppendLine("        {");
            sb.AppendLine($"            private readonly {tableName} _table;");
            sb.AppendLine("            private readonly Fixed64Vec2 _center;");
            sb.AppendLine("            private readonly Fixed64 _radiusSq;");
            sb.AppendLine("            private readonly int _minChunkX, _maxChunkX, _minChunkY, _maxChunkY;");
            sb.AppendLine("            private readonly int _minWorldX, _maxWorldX, _minWorldY, _maxWorldY;");
            sb.AppendLine("            private int _chunkX, _chunkY;  // Current chunk coordinates (direct lookup)");
            sb.AppendLine("            private int _cellX, _cellY;   // Current cell within chunk");
            sb.AppendLine("            private int _minCellX, _maxCellX, _minCellY, _maxCellY;  // Cell range for current chunk");
            sb.AppendLine("            private int _poolIdx;         // Pool index for current chunk (-1 if none)");
            sb.AppendLine("            private int _entityIdx;       // Current entity index within cell");
            sb.AppendLine("            private int _entityEnd;       // End index for current cell");
            sb.AppendLine("            private int _current;         // Current slot value");
            sb.AppendLine();
            sb.AppendLine($"            public RadiusQueryEnumerator({tableName} table, Fixed64Vec2 center, Fixed64 radius)");
            sb.AppendLine("            {");
            sb.AppendLine("                _table = table;");
            sb.AppendLine("                _center = center;");
            sb.AppendLine("                _radiusSq = radius * radius;  // Compute once, no Sqrt needed");
            sb.AppendLine();
            sb.AppendLine("                // Use radius directly - no expensive Sqrt call");
            sb.AppendLine("                int centerWorldX = center.X.ToInt();");
            sb.AppendLine("                int centerWorldY = center.Y.ToInt();");
            sb.AppendLine("                int radiusInt = radius.ToInt() + 1; // +1 for safety margin");
            sb.AppendLine();
            sb.AppendLine("                // Compute world bounding box");
            sb.AppendLine("                _minWorldX = centerWorldX - radiusInt;");
            sb.AppendLine("                _maxWorldX = centerWorldX + radiusInt;");
            sb.AppendLine("                _minWorldY = centerWorldY - radiusInt;");
            sb.AppendLine("                _maxWorldY = centerWorldY + radiusInt;");
            sb.AppendLine();
            sb.AppendLine("                // Compute chunk range from bounding box");
            sb.AppendLine("                _minChunkX = _minWorldX >= 0 ? _minWorldX / ChunkSize : (_minWorldX - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _maxChunkX = _maxWorldX >= 0 ? _maxWorldX / ChunkSize : (_maxWorldX - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _minChunkY = _minWorldY >= 0 ? _minWorldY / ChunkSize : (_minWorldY - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine("                _maxChunkY = _maxWorldY >= 0 ? _maxWorldY / ChunkSize : (_maxWorldY - ChunkSize + 1) / ChunkSize;");
            sb.AppendLine();
            sb.AppendLine("                // Start before first chunk");
            sb.AppendLine("                _chunkX = _minChunkX - 1;");
            sb.AppendLine("                _chunkY = _minChunkY;");
            sb.AppendLine("                _cellX = 0;");
            sb.AppendLine("                _cellY = 0;");
            sb.AppendLine("                _minCellX = 0;");
            sb.AppendLine("                _maxCellX = 0;");
            sb.AppendLine("                _minCellY = 0;");
            sb.AppendLine("                _maxCellY = 0;");
            sb.AppendLine("                _poolIdx = -1;");
            sb.AppendLine("                _entityIdx = 0;");
            sb.AppendLine("                _entityEnd = 0;");
            sb.AppendLine("                _current = -1;");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            public int Current => _current;");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            public bool MoveNext()");
            sb.AppendLine("            {");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    // Try to get next entity from current cell");
            sb.AppendLine("                    while (_entityIdx < _entityEnd)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        int slot = _table._sortedOrder[_entityIdx++];");
            sb.AppendLine("                        var pos = _table.Position(slot);");
            sb.AppendLine("                        // Check if entity is within radius using squared distance");
            sb.AppendLine("                        Fixed64 distSq = Fixed64Vec2.DistanceSquared(_center, pos);");
            sb.AppendLine("                        if (distSq <= _radiusSq)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            _current = slot;");
            sb.AppendLine("                            return true;");
            sb.AppendLine("                        }");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Move to next cell or chunk");
            sb.AppendLine("                    if (!AdvanceToNextCell())");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _current = -1;");
            sb.AppendLine("                        return false;");
            sb.AppendLine("                    }");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            private bool AdvanceToNextCell()");
            sb.AppendLine("            {");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    // If we have a valid chunk, try next cell");
            sb.AppendLine("                    if (_poolIdx >= 0)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _cellX++;");
            sb.AppendLine("                        if (_cellX > _maxCellX)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            _cellX = _minCellX;");
            sb.AppendLine("                            _cellY++;");
            sb.AppendLine("                        }");
            sb.AppendLine("                        if (_cellY <= _maxCellY)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            ref var grid = ref _table._chunkGridPool[_poolIdx];");
            sb.AppendLine();
            sb.AppendLine("                            // Hierarchical coarse mask checks - skip empty regions");
            sb.AppendLine("                            if (HasChunkL2)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                int l2X = _cellX >> ChunkL2Shift;");
            sb.AppendLine("                                int l2Y = _cellY >> ChunkL2Shift;");
            sb.AppendLine("                                if ((grid.CoarseMaskL2 & (1UL << (l2Y * ChunkL2GridSize + l2X))) == 0)");
            sb.AppendLine("                                {");
            sb.AppendLine("                                    int nextL2X = (l2X + 1) << ChunkL2Shift;");
            sb.AppendLine("                                    _cellX = Math.Min(nextL2X, _maxCellX + 1) - 1;");
            sb.AppendLine("                                    continue;");
            sb.AppendLine("                                }");
            sb.AppendLine("                            }");
            sb.AppendLine("                            if (HasChunkL1)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                int l1X = _cellX >> ChunkL1Shift;");
            sb.AppendLine("                                int l1Y = _cellY >> ChunkL1Shift;");
            sb.AppendLine("                                if ((grid.CoarseMaskL1[l1Y] & (1UL << l1X)) == 0)");
            sb.AppendLine("                                {");
            sb.AppendLine("                                    int nextL1X = (l1X + 1) << ChunkL1Shift;");
            sb.AppendLine("                                    _cellX = Math.Min(nextL1X, _maxCellX + 1) - 1;");
            sb.AppendLine("                                    continue;");
            sb.AppendLine("                                }");
            sb.AppendLine("                            }");
            sb.AppendLine();
            sb.AppendLine("                            int cellIdx = _cellX + _cellY * GridSize;");
            sb.AppendLine("                            int count = grid.CellCount[cellIdx];");
            sb.AppendLine("                            if (count > 0)");
            sb.AppendLine("                            {");
            sb.AppendLine("                                _entityIdx = grid.CellStart[cellIdx];");
            sb.AppendLine("                                _entityEnd = _entityIdx + count;");
            sb.AppendLine("                                return true;");
            sb.AppendLine("                            }");
            sb.AppendLine("                            continue; // Empty cell, try next");
            sb.AppendLine("                        }");
            sb.AppendLine("                        // Exhausted cells in this chunk");
            sb.AppendLine("                        _poolIdx = -1;");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Need to find next chunk (direct lookup)");
            sb.AppendLine("                    if (!AdvanceToNextChunk())");
            sb.AppendLine("                        return false;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine("            private bool AdvanceToNextChunk()");
            sb.AppendLine("            {");
            sb.AppendLine("                // Direct chunk lookup - O(query chunks) instead of O(active chunks)");
            sb.AppendLine("                while (true)");
            sb.AppendLine("                {");
            sb.AppendLine("                    _chunkX++;");
            sb.AppendLine("                    if (_chunkX > _maxChunkX)");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _chunkX = _minChunkX;");
            sb.AppendLine("                        _chunkY++;");
            sb.AppendLine("                        if (_chunkY > _maxChunkY)");
            sb.AppendLine("                            return false;  // No more chunks in range");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Direct lookup of this chunk");
            sb.AppendLine("                    var key = new ChunkKey(_chunkX, _chunkY);");
            sb.AppendLine("                    if (!_table._chunkToPoolIndex.TryGetValue(key, out _poolIdx))");
            sb.AppendLine("                    {");
            sb.AppendLine("                        _poolIdx = -1;");
            sb.AppendLine("                        continue;  // Chunk doesn't exist, try next");
            sb.AppendLine("                    }");
            sb.AppendLine();
            sb.AppendLine("                    // Compute cell range within this chunk that overlaps query bbox");
            sb.AppendLine("                    int chunkWorldMinX = _chunkX * ChunkSize;");
            sb.AppendLine("                    int chunkWorldMinY = _chunkY * ChunkSize;");
            sb.AppendLine();
            sb.AppendLine("                    // Clamp query bbox to chunk bounds and convert to local cells");
            sb.AppendLine("                    int localMinX = Math.Max(0, _minWorldX - chunkWorldMinX);");
            sb.AppendLine("                    int localMaxX = Math.Min(ChunkSize - 1, _maxWorldX - chunkWorldMinX);");
            sb.AppendLine("                    int localMinY = Math.Max(0, _minWorldY - chunkWorldMinY);");
            sb.AppendLine("                    int localMaxY = Math.Min(ChunkSize - 1, _maxWorldY - chunkWorldMinY);");
            sb.AppendLine();
            sb.AppendLine("                    // Convert local coords to cell indices");
            sb.AppendLine("                    _minCellX = Math.Clamp(localMinX / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _maxCellX = Math.Clamp(localMaxX / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _minCellY = Math.Clamp(localMinY / CellSize, 0, GridSize - 1);");
            sb.AppendLine("                    _maxCellY = Math.Clamp(localMaxY / CellSize, 0, GridSize - 1);");
            sb.AppendLine();
            sb.AppendLine("                    // Start before first cell (will be incremented)");
            sb.AppendLine("                    _cellX = _minCellX - 1;");
            sb.AppendLine("                    _cellY = _minCellY;");
            sb.AppendLine("                    return true;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
    }
}
