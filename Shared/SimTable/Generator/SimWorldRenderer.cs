#nullable enable
using Microsoft.CodeAnalysis;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SimTable.Generator
{
    internal static class SimWorldRenderer
    {
        public static string Render(ImmutableArray<SchemaModel?> models)
        {
            var validModels = models.Where(m => m != null).Select(m => m!).ToList();
            if (validModels.Count == 0)
            {
                return string.Empty;
            }

            var firstNs = validModels[0].Type.ContainingNamespace?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? "global::";

            var sb = new StringBuilder(8192);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using DerpTech.Rollback;");
            sb.AppendLine("using Friflo.Engine.ECS;");
            sb.AppendLine("using Core;");
            sb.AppendLine("using DerpTech.DesyncDetection;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(firstNs) && firstNs != "global::")
            {
                sb.Append("namespace ").Append(firstNs.Replace("global::", string.Empty)).AppendLine();
                sb.AppendLine("{");
            }

            sb.AppendLine("    public sealed unsafe partial class SimWorld : IDisposable, ISnapshotProvider, IDesyncExportable");
            sb.AppendLine("    {");

            foreach (var model in validModels)
            {
                var tableName = model.Type.Name + "Table";
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"        public readonly {tableName} {fieldName};");
            }
            sb.AppendLine();

            sb.AppendLine("        public SimWorld()");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var tableName = model.Type.Name + "Table";
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName} = new {tableName}();");
            }
            sb.AppendLine();

            // Auto-allocate data-only tables with AutoAllocate=true
            bool hasAutoAllocate = false;
            foreach (var model in validModels)
            {
                if (model.IsDataOnly && model.AutoAllocate)
                {
                    if (!hasAutoAllocate)
                    {
                        sb.AppendLine("            // Auto-allocate singleton tables with defaults");
                        hasAutoAllocate = true;
                    }
                    var fieldName = model.Type.Name + "s";
                    sb.AppendLine($"            {fieldName}.Allocate();");
                }
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public void BeginFrame()");
            sb.AppendLine("        {");
            sb.AppendLine("            // Spatial sort for collision detection");
            foreach (var model in validModels)
            {
                // Skip SpatialSort for data-only tables (they don't have this method)
                if (!model.IsDataOnly)
                {
                    var fieldName = model.Type.Name + "s";
                    sb.AppendLine($"            {fieldName}.SpatialSort();");
                }
            }
            sb.AppendLine();
            sb.AppendLine("            // Recompute computed state fields (after rollback or hot-reload)");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName}.RecomputeAll(this);");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate EndFrame() - syncs positions from SimWorld to Friflo ECS and handles orphan deletion
            // Uses chunked iteration for optimal performance (~0% overhead vs ~55% for per-entity)
            var spatialModels = validModels.Where(m => m.HasPositionField).ToList();
            if (spatialModels.Count > 0)
            {
                sb.AppendLine("        /// <summary>");
                sb.AppendLine("        /// Syncs positions from SimWorld tables to Friflo ECS entities and deletes orphaned entities.");
                sb.AppendLine("        /// Call this at the end of each frame after simulation updates.");
                sb.AppendLine("        /// Uses chunked iteration for optimal performance.");
                sb.AppendLine("        /// </summary>");
                sb.AppendLine("        public void EndFrame(EntityStore store)");
                sb.AppendLine("        {");
                sb.AppendLine("            var commandBuffer = store.GetCommandBuffer();");
                sb.AppendLine("            var syncQuery = store.Query<SimSlotRef, TransformSim2D>();");
                sb.AppendLine("            int deletedCount = 0;");
                sb.AppendLine();
                sb.AppendLine("            foreach (var chunk in syncQuery.Chunks)");
                sb.AppendLine("            {");
                sb.AppendLine("                int chunkLength = chunk.Length;");
                sb.AppendLine("                var slotRefs = chunk.Chunk1.Span;");
                sb.AppendLine("                var simTransforms = chunk.Chunk2.Span;");
                sb.AppendLine("                var entities = chunk.Entities;");
                sb.AppendLine();
                sb.AppendLine("                for (int i = 0; i < chunkLength; i++)");
                sb.AppendLine("                {");
                sb.AppendLine("                    ref readonly var slotRef = ref slotRefs[i];");
                sb.AppendLine("                    var handle = slotRef.Handle;");
                sb.AppendLine();
                sb.AppendLine("                    switch (handle.TableId)");
                sb.AppendLine("                    {");
                foreach (var model in spatialModels)
                {
                    var typeName = model.Type.Name;
                    var tableName = typeName + "Table";
                    var fieldName = typeName + "s";
                    sb.AppendLine($"                        case {tableName}.TableIdConst:");
                    sb.AppendLine("                        {");
                    sb.AppendLine($"                            int slot = {fieldName}.GetSlot(handle);");
                    sb.AppendLine("                            if (slot < 0) { commandBuffer.DeleteEntity(entities[i]); deletedCount++; break; }");
                    sb.AppendLine($"                            var newPos = {fieldName}.Position(slot).ToVector2();");
                    sb.AppendLine("                            // Only shift previous when position actually changed (sim tick ran)");
                    sb.AppendLine($"                            if (newPos != simTransforms[i].Position)");
                    sb.AppendLine("                            {");
                    sb.AppendLine($"                                simTransforms[i].PreviousPosition = simTransforms[i].Position;");
                    sb.AppendLine($"                                simTransforms[i].Position = newPos;");
                    sb.AppendLine("                            }");
                    if (model.HasVelocityField)
                        sb.AppendLine($"                            simTransforms[i].Velocity = {fieldName}.Velocity(slot).ToVector2();");
                    sb.AppendLine("                            break;");
                    sb.AppendLine("                        }");
                }
                sb.AppendLine("                        default:");
                sb.AppendLine("                            // Unknown table - delete orphan");
                sb.AppendLine("                            commandBuffer.DeleteEntity(entities[i]);");
                sb.AppendLine("                            deletedCount++;");
                sb.AppendLine("                            break;");
                sb.AppendLine("                    }");
                sb.AppendLine("                }");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            if (deletedCount > 0)");
                sb.AppendLine("                commandBuffer.Playback();");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            // Generate HasPosition<TRow>() static method for auto Transform2D in spawner
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Returns true if the row type has a Position field and should auto-add Transform2D.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static bool HasPosition<TRow>() where TRow : struct");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var typeName = model.Type.Name;
                var hasPosition = model.HasPositionField ? "true" : "false";
                sb.AppendLine($"            if (typeof(TRow) == typeof({typeName})) return {hasPosition};");
            }
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public int TotalSlabSize");
            sb.AppendLine("        {");
            sb.AppendLine("            get");
            sb.AppendLine("            {");
            sb.Append("                return ");
            for (int i = 0; i < validModels.Count; i++)
            {
                var fieldName = validModels[i].Type.Name + "s";
                if (i > 0)
                {
                    sb.Append(" + ");
                }
                sb.Append($"{fieldName}.SlabSize");
            }
            sb.AppendLine(";");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public int TotalMetaSize");
            sb.AppendLine("        {");
            sb.AppendLine("            get");
            sb.AppendLine("            {");
            sb.Append("                return ");
            for (int i = 0; i < validModels.Count; i++)
            {
                var tableName = validModels[i].Type.Name + "Table";
                if (i > 0)
                {
                    sb.Append(" + ");
                }
                sb.Append($"{tableName}.MetaSize");
            }
            sb.AppendLine(";");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public int TotalSnapshotSize => TotalSlabSize + TotalMetaSize;");
            sb.AppendLine();

            sb.AppendLine("        public void SaveTo(byte* dest)");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName}.SaveTo(dest);");
                sb.AppendLine($"            dest += {fieldName}.SlabSize;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public void LoadFrom(byte* src)");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName}.LoadFrom(src);");
                sb.AppendLine($"            src += {fieldName}.SlabSize;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public void SaveMetaTo(Span<byte> dest)");
            sb.AppendLine("        {");
            sb.AppendLine("            int offset = 0;");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                var tableName = model.Type.Name + "Table";
                sb.AppendLine($"            {fieldName}.SaveMetaTo(dest.Slice(offset, {tableName}.MetaSize));");
                sb.AppendLine($"            offset += {tableName}.MetaSize;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public void LoadMetaFrom(ReadOnlySpan<byte> src)");
            sb.AppendLine("        {");
            sb.AppendLine("            int offset = 0;");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                var tableName = model.Type.Name + "Table";
                sb.AppendLine($"            {fieldName}.LoadMetaFrom(src.Slice(offset, {tableName}.MetaSize));");
                sb.AppendLine($"            offset += {tableName}.MetaSize;");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public void Dispose()");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName}.Dispose();");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate ResetAllTables method
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Completely resets all tables to initial state.");
            sb.AppendLine("        /// Call this when restarting the game.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public void ResetAllTables()");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            {fieldName}.Reset();");
            }
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public ulong ComputeStateHash()");
            sb.AppendLine("        {");
            sb.AppendLine("            ulong hash = 14695981039346656037UL;");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"            hash ^= {fieldName}.ComputeStateHash();");
                sb.AppendLine("            hash *= 1099511628211UL;");
            }
            sb.AppendLine("            return hash;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate ComputePerTableHashes()
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Returns per-table state hashes for debugging desync issues.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public global::System.Collections.Generic.Dictionary<string, ulong> ComputePerTableHashes()");
            sb.AppendLine("        {");
            sb.AppendLine("            return new global::System.Collections.Generic.Dictionary<string, ulong>");
            sb.AppendLine("            {");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"                [\"{fieldName}\"] = {fieldName}.ComputeStateHash(),");
            }
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate GetTable<TRow>()
            sb.AppendLine("        public global::SimTable.ISimTable GetTable<TRow>() where TRow : struct");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var typeName = model.Type.Name;
                var fieldName = typeName + "s";
                sb.AppendLine($"            if (typeof(TRow) == typeof({typeName})) return {fieldName};");
            }
            sb.AppendLine("            throw new ArgumentException($\"Unknown row type: {typeof(TRow)}\");");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate GetTableById(int)
            sb.AppendLine("        public global::SimTable.ISimTable GetTableById(int tableId)");
            sb.AppendLine("        {");
            sb.AppendLine("            return tableId switch");
            sb.AppendLine("            {");
            foreach (var model in validModels)
            {
                var tableName = model.Type.Name + "Table";
                var fieldName = model.Type.Name + "s";
                sb.AppendLine($"                {tableName}.TableIdConst => {fieldName},");
            }
            sb.AppendLine("                _ => throw new ArgumentException($\"Unknown table ID: {tableId}\")");
            sb.AppendLine("            };");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate GetTableId<TRow>()
            sb.AppendLine("        public static int GetTableId<TRow>() where TRow : struct");
            sb.AppendLine("        {");
            foreach (var model in validModels)
            {
                var typeName = model.Type.Name;
                var tableName = typeName + "Table";
                sb.AppendLine($"            if (typeof(TRow) == typeof({typeName})) return {tableName}.TableIdConst;");
            }
            sb.AppendLine("            throw new ArgumentException($\"Unknown row type: {typeof(TRow)}\");");
            sb.AppendLine("        }");
            sb.AppendLine();

            // Generate Allocate<TRow>() and Free<TRow>()
            sb.AppendLine("        public global::SimTable.SimHandle Allocate<TRow>() where TRow : struct => GetTable<TRow>().Allocate();");
            sb.AppendLine("        public void Free<TRow>(int stableId) where TRow : struct => GetTable<TRow>().Free(stableId);");
            sb.AppendLine("        public void Free<TRow>(global::SimTable.SimHandle handle) where TRow : struct => GetTable<TRow>().Free(handle);");
            sb.AppendLine();

            // Generate ExportDebugJson for entire SimWorld
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Exports complete SimWorld state to JSON for desync debugging.");
            sb.AppendLine("        /// Includes all tables with all fields and their raw values.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public void ExportDebugJson(System.Text.Json.Utf8JsonWriter writer)");
            sb.AppendLine("        {");
            sb.AppendLine("            writer.WriteStartObject();");
            sb.AppendLine("            writer.WriteString(\"stateHash\", ComputeStateHash().ToString(\"X16\"));");
            sb.AppendLine();
            sb.AppendLine("            // Per-table hashes for quick comparison");
            sb.AppendLine("            writer.WriteStartObject(\"tableHashes\");");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                var propName = char.ToLowerInvariant(model.Type.Name[0]) + model.Type.Name.Substring(1) + "s";
                sb.AppendLine($"            writer.WriteString(\"{propName}\", {fieldName}.ComputeStateHash().ToString(\"X16\"));");
            }
            sb.AppendLine("            writer.WriteEndObject();");
            sb.AppendLine();
            sb.AppendLine("            // Full table data");
            foreach (var model in validModels)
            {
                var fieldName = model.Type.Name + "s";
                var propName = char.ToLowerInvariant(model.Type.Name[0]) + model.Type.Name.Substring(1) + "s";
                sb.AppendLine($"            writer.WritePropertyName(\"{propName}\");");
                sb.AppendLine($"            {fieldName}.ExportDebugJson(writer);");
                sb.AppendLine();
            }
            sb.AppendLine("            writer.WriteEndObject();");
            sb.AppendLine("        }");

            sb.AppendLine("    }");

            if (!string.IsNullOrEmpty(firstNs) && firstNs != "global::")
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }
    }
}

