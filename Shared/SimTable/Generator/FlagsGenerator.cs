#nullable enable
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SimTable.Generator
{
    [Generator]
    public sealed class FlagsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var flagEnums = context.SyntaxProvider.ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: "SimTable.GenerateFlagsAttribute",
                predicate: static (node, _) => node is EnumDeclarationSyntax,
                transform: static (ctx, _) => TransformEnum(ctx))
                .Where(static model => model is not null);

            context.RegisterSourceOutput(flagEnums, static (spc, model) =>
            {
                if (model is null) return;
                var source = RenderFlagsExtensions(model);
                var hint = model.Value.EnumName + "Extensions.g.cs";
                spc.AddSource(hint, SourceText.From(source, Encoding.UTF8));
            });
        }

        private static FlagsEnumModel? TransformEnum(GeneratorAttributeSyntaxContext ctx)
        {
            var enumDecl = (EnumDeclarationSyntax)ctx.TargetNode;
            var enumSymbol = (INamedTypeSymbol)ctx.TargetSymbol;

            // Verify it has [Flags] attribute
            bool hasFlags = enumSymbol.GetAttributes().Any(a =>
                a.AttributeClass?.ToDisplayString() == "System.FlagsAttribute");

            if (!hasFlags)
            {
                return null;
            }

            var ns = enumSymbol.ContainingNamespace?.ToDisplayString() ?? "";
            var enumName = enumSymbol.Name;
            var underlyingType = enumSymbol.EnumUnderlyingType?.ToDisplayString() ?? "int";

            // Get all enum members except "None"
            var members = enumSymbol.GetMembers()
                .OfType<IFieldSymbol>()
                .Where(f => f.HasConstantValue && f.Name != "None")
                .Select(f => f.Name)
                .ToImmutableArray();

            return new FlagsEnumModel(ns, enumName, underlyingType, members);
        }

        private static string RenderFlagsExtensions(FlagsEnumModel? model)
        {
            if (model is null) return "";
            var m = model.Value;

            var sb = new StringBuilder(4096);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();

            if (!string.IsNullOrEmpty(m.Namespace))
            {
                sb.Append("namespace ").Append(m.Namespace).AppendLine();
                sb.AppendLine("{");
            }

            sb.AppendLine($"    public static class {m.EnumName}Extensions");
            sb.AppendLine("    {");

            foreach (var flag in m.Members)
            {
                // For flags that start with "Is", use the name directly for the check method
                // e.g., IsActive -> IsActive(), IsDead -> IsDead()
                // For others, prefix with "Is": HordeActive -> IsHordeActive()
                var checkMethodName = flag.StartsWith("Is") ? flag : "Is" + flag;

                // For Set/With/Without, strip the "Is" prefix if present
                // e.g., IsActive -> SetActive(), WithActive(), WithoutActive()
                var baseName = flag.StartsWith("Is") ? flag.Substring(2) : flag;

                // {CheckMethod}() - check if flag is set
                sb.AppendLine($"        /// <summary>Returns true if {flag} flag is set.</summary>");
                sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        public static bool {checkMethodName}(this {m.EnumName} flags)");
                sb.AppendLine("        {");
                sb.AppendLine($"            return (flags & {m.EnumName}.{flag}) != 0;");
                sb.AppendLine("        }");
                sb.AppendLine();

                // With{BaseName}() - set the flag
                sb.AppendLine($"        /// <summary>Returns flags with {flag} set.</summary>");
                sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        public static {m.EnumName} With{baseName}(this {m.EnumName} flags)");
                sb.AppendLine("        {");
                sb.AppendLine($"            return flags | {m.EnumName}.{flag};");
                sb.AppendLine("        }");
                sb.AppendLine();

                // Without{BaseName}() - clear the flag
                sb.AppendLine($"        /// <summary>Returns flags with {flag} cleared.</summary>");
                sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        public static {m.EnumName} Without{baseName}(this {m.EnumName} flags)");
                sb.AppendLine("        {");
                sb.AppendLine($"            return flags & ~{m.EnumName}.{flag};");
                sb.AppendLine("        }");
                sb.AppendLine();

                // Set{BaseName}(bool) - conditional set/clear
                sb.AppendLine($"        /// <summary>Returns flags with {flag} set or cleared based on value.</summary>");
                sb.AppendLine("        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.AppendLine($"        public static {m.EnumName} Set{baseName}(this {m.EnumName} flags, bool value)");
                sb.AppendLine("        {");
                sb.AppendLine($"            return value ? flags | {m.EnumName}.{flag} : flags & ~{m.EnumName}.{flag};");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("    }");

            if (!string.IsNullOrEmpty(m.Namespace))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

        private readonly struct FlagsEnumModel
        {
            public readonly string Namespace;
            public readonly string EnumName;
            public readonly string UnderlyingType;
            public readonly ImmutableArray<string> Members;

            public FlagsEnumModel(string ns, string enumName, string underlyingType, ImmutableArray<string> members)
            {
                Namespace = ns;
                EnumName = enumName;
                UnderlyingType = underlyingType;
                Members = members;
            }
        }
    }
}
