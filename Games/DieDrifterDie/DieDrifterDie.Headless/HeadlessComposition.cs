using System;
using System.Collections.Generic;
using System.Diagnostics;
using Friflo.Engine.ECS;
using Pure.DI;
using Serilog;
using DieDrifterDie.GameData;
using DieDrifterDie.Infrastructure.Rollback;
using DieDrifterDie.Presentation.Entities;
using DieDrifterDie.Simulation;
using DieDrifterDie.Simulation.Components;
using DieDrifterDie.Simulation.Systems;
using DieDrifterDie.Simulation.Systems.SimTable;
using Core;
using DerpTech.Rollback;
using Pooled.Runtime;
using static Pure.DI.Lifetime;

namespace DieDrifterDie.Headless;

/// <summary>
/// Minimal composition for headless replay.
/// Creates only simulation components without UI/ECS/Raylib dependencies.
/// Mirrors GameComposition.Simulation bindings for deterministic replay.
/// </summary>
public sealed partial class HeadlessComposition : IDisposable
{
    private const int InputBufferFrames = 64;

    [Conditional("DI")]
    private static void Setup() => DI.Setup(nameof(HeadlessComposition))
        // Arguments
        .Arg<ReplayConfig>("replayConfig")
        .Arg<SessionSeed>("sessionSeed")
        // Simulation world and core components
        .Bind().As(Singleton).To<SimWorld>()
        // EntityStore is needed by EntitySpawner even in headless mode
        .Bind().As(Singleton).To<EntityStore>()
        .Bind().As(Singleton).To<EntitySpawner>()
        // Game data (static data tables)
        .Bind().As(Singleton).To(ctx => GameDataManagerFactory.Create())
        // Simulation services
        .Bind<IPoolRegistry>().As(Singleton).To<World>()
        // DerivedSystemRunner - generated from Setup method in DerivedSystemRunner.cs
        // Constructor is generated, we just need to wire up dependencies
        .Bind().As(Singleton).To(ctx =>
        {
            ctx.Inject(out SimWorld simWorld);
            return new DerivedSystemRunner(simWorld);
        })
        // Input buffer and rollback
        .Bind<MultiPlayerInputBuffer<GameInput>>().As(Singleton).To(ctx =>
        {
            return new MultiPlayerInputBuffer<GameInput>(InputBufferFrames, 8); // Max 8 players
        })
        .Bind<RollbackManager<GameInput>>().As(Singleton).To(ctx =>
        {
            ctx.Inject(out SimWorld simWorld);
            ctx.Inject(out MultiPlayerInputBuffer<GameInput> inputBuffer);
            return new RollbackManager<GameInput>(simWorld, inputBuffer, Log.Logger);
        })
        // Replay manager - start replay from file
        .Bind<ReplayManager<GameInput>>().As(Singleton).To(ctx =>
        {
            ctx.Inject(out ReplayConfig replayConfig);
            ctx.Inject(out RollbackManager<GameInput> rollbackManager);

            var replayManager = new ReplayManager<GameInput>();
            if (!string.IsNullOrEmpty(replayConfig.ReplayFilePath))
            {
                int playerCount = replayManager.StartReplay(replayConfig.ReplayFilePath);
                rollbackManager.SetPlayerCount(playerCount);
                rollbackManager.SetLocalPlayerId(0);
            }
            return replayManager;
        })
        // SimTable systems
        .Bind().As(Singleton).To<CountdownSystem>()
        // System list (order matters for determinism) - must match GameComposition.Simulation
        .Bind<IReadOnlyList<SimTableSystem>>().As(Singleton).To(ctx =>
        {
            ctx.Inject(out CountdownSystem countdown);
            return new List<SimTableSystem>
            {
                countdown,
            };
        })
        .Bind().As(Singleton).To<GameSimulation>()
        // Roots
        .Root<GameSimulation>("GameSimulation")
        .Root<RollbackManager<GameInput>>("RollbackManager")
        .Root<ReplayManager<GameInput>>("ReplayManager")
        .Root<DerivedSystemRunner>("DerivedSystemRunner");

    public HeadlessComposition(string replayFilePath)
        : this(new ReplayConfig(replayFilePath, null), new SessionSeed(0))
    {
    }

    // Dispose is generated by Pure.DI for owned singletons
}
