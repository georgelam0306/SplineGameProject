# Derp.DI - Generated Code Specification

This document specifies exactly what code the source generator produces.

## Input Example

```csharp
// AppComposition.cs
using Derp.DI;

namespace MyGame;

[Composition]
partial class AppComposition
{
    static void Setup() => DI.Setup()
        .Arg<NetworkConfig>("networkConfig")
        .Bind<ILogger>().As(Singleton).To(_ => Log.Logger)
        .Bind<NetworkService>().As(Singleton).To<NetworkService>()
        .Bind<GameStore>().As(Singleton).To<GameStore>()
        .Scope<GameComposition>()
        .Root<GameStore>("Store");
}

// GameComposition.cs
[Composition]
partial class GameComposition
{
    static void Setup() => DI.Setup()
        .Arg<PlayerConfig>("playerConfig")
        .Arg<SessionSeed>("sessionSeed")
        .Bind<SimWorld>().As(Singleton).To<SimWorld>()
        .Bind<Game>().As(Singleton).To<Game>()
        .Root<Game>("Game");
}
```

---

## Generated Output

### AppComposition.g.cs

```csharp
// <auto-generated/>
#nullable enable

namespace MyGame;

partial class AppComposition : global::System.IDisposable
{
    //==========================================================================
    // Arguments
    //==========================================================================

    private readonly global::MyGame.NetworkConfig _arg_networkConfig;

    //==========================================================================
    // Singleton Fields
    //==========================================================================

    private readonly global::System.Threading.Lock _lock = new();
    private global::Serilog.ILogger? _singleton_ILogger;
    private global::MyGame.NetworkService? _singleton_NetworkService;
    private global::MyGame.GameStore? _singleton_GameStore;
    private global::MyGame.GameComposition.Factory? _singleton_GameComposition_Factory;

    //==========================================================================
    // Disposal Tracking
    //==========================================================================

    private global::System.IDisposable?[] _disposables = new global::System.IDisposable?[8];
    private int _disposableCount;

    //==========================================================================
    // Constructor
    //==========================================================================

    public AppComposition(global::MyGame.NetworkConfig networkConfig)
    {
        _arg_networkConfig = networkConfig;
    }

    //==========================================================================
    // Roots
    //==========================================================================

    public global::MyGame.GameStore Store => Resolve_GameStore();

    //==========================================================================
    // Resolution Methods
    //==========================================================================

    internal global::MyGame.NetworkConfig Resolve_NetworkConfig() => _arg_networkConfig;

    internal global::Serilog.ILogger Resolve_ILogger()
    {
        if (_singleton_ILogger is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_ILogger is { } cached2) return cached2;
            var instance = global::Serilog.Log.Logger;
            return _singleton_ILogger = instance;
        }
    }

    internal global::MyGame.NetworkService Resolve_NetworkService()
    {
        if (_singleton_NetworkService is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_NetworkService is { } cached2) return cached2;
            var instance = new global::MyGame.NetworkService(
                Resolve_NetworkConfig()
            );
            TrackDisposable(instance);
            return _singleton_NetworkService = instance;
        }
    }

    internal global::MyGame.GameStore Resolve_GameStore()
    {
        if (_singleton_GameStore is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_GameStore is { } cached2) return cached2;
            var instance = new global::MyGame.GameStore(
                Resolve_GameComposition_Factory()  // Inject the factory!
            );
            TrackDisposable(instance);
            return _singleton_GameStore = instance;
        }
    }

    //==========================================================================
    // Scope Factory Resolution
    //==========================================================================

    internal global::MyGame.GameComposition.Factory Resolve_GameComposition_Factory()
    {
        if (_singleton_GameComposition_Factory is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_GameComposition_Factory is { } cached2) return cached2;
            var instance = new global::MyGame.GameComposition.Factory(this);
            return _singleton_GameComposition_Factory = instance;
        }
    }

    //==========================================================================
    // Disposal
    //==========================================================================

    private void TrackDisposable(object instance)
    {
        if (instance is global::System.IDisposable disposable)
        {
            if (_disposableCount >= _disposables.Length)
            {
                global::System.Array.Resize(ref _disposables, _disposables.Length * 2);
            }
            _disposables[_disposableCount++] = disposable;
        }
    }

    public void Dispose()
    {
        global::System.IDisposable?[] toDispose;
        int count;
        lock (_lock)
        {
            toDispose = _disposables;
            count = _disposableCount;
            _disposables = global::System.Array.Empty<global::System.IDisposable?>();
            _disposableCount = 0;

            _singleton_ILogger = null;
            _singleton_NetworkService = null;
            _singleton_GameStore = null;
            _singleton_GameComposition_Factory = null;
        }

        for (int i = count - 1; i >= 0; i--)
        {
            try { toDispose[i]?.Dispose(); }
            catch (global::System.Exception ex) { OnDisposeException(toDispose[i]!, ex); }
        }
    }

    partial void OnDisposeException(global::System.IDisposable instance, global::System.Exception exception);
}
```

### GameComposition.g.cs

```csharp
// <auto-generated/>
#nullable enable

namespace MyGame;

partial class GameComposition : global::System.IDisposable
{
    //==========================================================================
    // Parent Reference
    //==========================================================================

    private readonly global::MyGame.AppComposition _parent;

    //==========================================================================
    // Arguments (child-specific)
    //==========================================================================

    private readonly global::MyGame.PlayerConfig _arg_playerConfig;
    private readonly global::MyGame.SessionSeed _arg_sessionSeed;

    //==========================================================================
    // Singleton Fields (child-specific)
    //==========================================================================

    private readonly global::System.Threading.Lock _lock = new();
    private global::MyGame.SimWorld? _singleton_SimWorld;
    private global::MyGame.Game? _singleton_Game;

    //==========================================================================
    // Disposal Tracking
    //==========================================================================

    private global::System.IDisposable?[] _disposables = new global::System.IDisposable?[8];
    private int _disposableCount;

    //==========================================================================
    // Constructor (internal - use Factory.Create)
    //==========================================================================

    internal GameComposition(
        global::MyGame.AppComposition parent,
        global::MyGame.PlayerConfig playerConfig,
        global::MyGame.SessionSeed sessionSeed)
    {
        _parent = parent;
        _arg_playerConfig = playerConfig;
        _arg_sessionSeed = sessionSeed;
    }

    //==========================================================================
    // Roots
    //==========================================================================

    public global::MyGame.Game Game => Resolve_Game();

    //==========================================================================
    // Resolution Methods - Inherited (delegate to parent)
    //==========================================================================

    internal global::MyGame.NetworkConfig Resolve_NetworkConfig()
        => _parent.Resolve_NetworkConfig();

    internal global::Serilog.ILogger Resolve_ILogger()
        => _parent.Resolve_ILogger();

    internal global::MyGame.NetworkService Resolve_NetworkService()
        => _parent.Resolve_NetworkService();

    //==========================================================================
    // Resolution Methods - Local Args
    //==========================================================================

    internal global::MyGame.PlayerConfig Resolve_PlayerConfig() => _arg_playerConfig;
    internal global::MyGame.SessionSeed Resolve_SessionSeed() => _arg_sessionSeed;

    //==========================================================================
    // Resolution Methods - Local Bindings
    //==========================================================================

    internal global::MyGame.SimWorld Resolve_SimWorld()
    {
        if (_singleton_SimWorld is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_SimWorld is { } cached2) return cached2;
            var instance = new global::MyGame.SimWorld();
            TrackDisposable(instance);
            return _singleton_SimWorld = instance;
        }
    }

    internal global::MyGame.Game Resolve_Game()
    {
        if (_singleton_Game is { } cached) return cached;
        lock (_lock)
        {
            if (_singleton_Game is { } cached2) return cached2;
            var instance = new global::MyGame.Game(
                Resolve_SimWorld(),        // Local
                Resolve_NetworkService(),  // Inherited → parent
                Resolve_ILogger(),         // Inherited → parent
                Resolve_PlayerConfig()     // Local arg
            );
            TrackDisposable(instance);
            return _singleton_Game = instance;
        }
    }

    //==========================================================================
    // Disposal (only child's singletons)
    //==========================================================================

    private void TrackDisposable(object instance)
    {
        if (instance is global::System.IDisposable disposable)
        {
            if (_disposableCount >= _disposables.Length)
            {
                global::System.Array.Resize(ref _disposables, _disposables.Length * 2);
            }
            _disposables[_disposableCount++] = disposable;
        }
    }

    public void Dispose()
    {
        global::System.IDisposable?[] toDispose;
        int count;
        lock (_lock)
        {
            toDispose = _disposables;
            count = _disposableCount;
            _disposables = global::System.Array.Empty<global::System.IDisposable?>();
            _disposableCount = 0;

            _singleton_SimWorld = null;
            _singleton_Game = null;
        }

        for (int i = count - 1; i >= 0; i--)
        {
            try { toDispose[i]?.Dispose(); }
            catch (global::System.Exception ex) { OnDisposeException(toDispose[i]!, ex); }
        }

        // NOTE: _parent is NOT disposed
    }

    partial void OnDisposeException(global::System.IDisposable instance, global::System.Exception exception);

    //==========================================================================
    // Nested Factory Class
    //==========================================================================

    /// <summary>
    /// Factory for creating <see cref="GameComposition"/> scopes.
    /// Inject this into services that need to create game sessions.
    /// </summary>
    public sealed class Factory
    {
        private readonly global::MyGame.AppComposition _parent;

        internal Factory(global::MyGame.AppComposition parent)
        {
            _parent = parent;
        }

        /// <summary>Creates a new game composition scope.</summary>
        /// <param name="playerConfig">Configuration for players in this session.</param>
        /// <param name="sessionSeed">Seed for deterministic random generation.</param>
        /// <returns>A new <see cref="GameComposition"/> that must be disposed when the game ends.</returns>
        public global::MyGame.GameComposition Create(
            global::MyGame.PlayerConfig playerConfig,
            global::MyGame.SessionSeed sessionSeed)
        {
            return new global::MyGame.GameComposition(_parent, playerConfig, sessionSeed);
        }
    }
}
```

---

## Key Patterns

### 1. Factory is Nested in Child

```csharp
partial class GameComposition
{
    public sealed class Factory { ... }
}
```

- Lives inside the child composition class
- Clear naming: `GameComposition.Factory`
- Constructor is `internal` - only Factory can create instances

### 2. Factory is Auto-Registered in Parent

When parent declares `.Scope<GameComposition>()`:

```csharp
// Parent generates:
internal GameComposition.Factory Resolve_GameComposition_Factory()
{
    // Singleton factory, passes 'this' as parent reference
    return _singleton_GameComposition_Factory ??= new GameComposition.Factory(this);
}
```

### 3. GameStore Injects Factory

```csharp
public class GameStore
{
    public GameStore(GameComposition.Factory gameFactory) { ... }
}

// Generator resolves constructor deps:
new GameStore(Resolve_GameComposition_Factory())
```

### 4. Child Resolution Delegates to Parent

For inherited bindings:

```csharp
// Child generates forwarding methods
internal ILogger Resolve_ILogger() => _parent.Resolve_ILogger();
internal NetworkService Resolve_NetworkService() => _parent.Resolve_NetworkService();
```

### 5. Override Parent Binding

```csharp
// Child Setup:
.Bind<ILogger>().As(Singleton).To(ctx => {
    ctx.InjectFromParent(out ILogger parentLogger);
    return new ScopedLogger(parentLogger, "Game");
})
```

Generated:

```csharp
internal ILogger Resolve_ILogger()
{
    if (_singleton_ILogger is { } cached) return cached;
    lock (_lock)
    {
        if (_singleton_ILogger is { } cached2) return cached2;
        // InjectFromParent → explicit _parent call
        var parentLogger = _parent.Resolve_ILogger();
        var instance = new ScopedLogger(parentLogger, "Game");
        return _singleton_ILogger = instance;
    }
}
```

---

## Resolution Method Naming

| Binding | Method Name |
|---------|-------------|
| `.Bind<ILogger>()` | `Resolve_ILogger()` |
| `.Bind<ILogger>("File")` | `Resolve_ILogger_File()` |
| `.Arg<PlayerConfig>()` | `Resolve_PlayerConfig()` |
| `.Scope<GameComposition>()` | `Resolve_GameComposition_Factory()` |

---

## How the Generator Links Parent-Child

1. **Parse parent**: Find `.Scope<GameComposition>()` in `AppComposition.Setup()`
2. **Parse child**: Find `[Composition] partial class GameComposition`
3. **Extract child args**: Parse `.Arg<T>()` calls → `Factory.Create(T1, T2)` signature
4. **Collect parent bindings**: All `.Bind<T>()` in parent
5. **Collect child bindings**: All `.Bind<T>()` in child
6. **Compute inherited**: Parent bindings not overridden in child
7. **Generate child**:
   - Forwarding methods for inherited bindings
   - Local resolution for child bindings
   - Factory nested class
8. **Generate parent**:
   - `Resolve_ChildComposition_Factory()` method
   - Factory singleton field

---

## Multi-Level Example

```csharp
// App → Game → Match hierarchy

[Composition]
partial class AppComposition
{
    static void Setup() => DI.Setup()
        .Bind<ILogger>().As(Singleton).To(_ => Log.Logger)
        .Scope<GameComposition>();
}

[Composition]
partial class GameComposition
{
    static void Setup() => DI.Setup()
        .Arg<PlayerConfig>("playerConfig")
        .Bind<SimWorld>().As(Singleton).To<SimWorld>()
        .Scope<MatchComposition>();
}

[Composition]
partial class MatchComposition
{
    static void Setup() => DI.Setup()
        .Arg<MatchConfig>("matchConfig")
        .Bind<MatchState>().As(Singleton).To<MatchState>();
}
```

**Generated resolution chain:**

```csharp
// MatchComposition resolving ILogger:
internal ILogger Resolve_ILogger() => _parent.Resolve_ILogger();

// GameComposition resolving ILogger:
internal ILogger Resolve_ILogger() => _parent.Resolve_ILogger();

// AppComposition has the actual binding:
internal ILogger Resolve_ILogger() => _singleton_ILogger ??= Log.Logger;
```

**Factory chain:**

```csharp
// AppComposition has:
internal GameComposition.Factory Resolve_GameComposition_Factory();

// GameComposition has:
internal MatchComposition.Factory Resolve_MatchComposition_Factory();
```

---

## Compile-Time Validation

The generator reports errors for:

| Error | Message |
|-------|---------|
| Missing binding | `DERP001: No binding for 'IFoo' in 'GameComposition' or any parent scope` |
| Circular dependency | `DERP002: Circular dependency detected: A → B → C → A` |
| Orphan scope | `DERP003: 'MatchComposition' is not declared as a scope in any parent` |
| Duplicate binding | `DERP004: 'ILogger' is bound twice in 'AppComposition'` |
| Invalid parent | `DERP005: '.Scope<Foo>()' but 'Foo' is not marked with [Composition]` |
